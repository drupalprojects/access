<?php

/**
 * @file
 * Tests for the access control kit module.
 */

/**
 * Provides common helper methods for access control kit module tests.
 */
class AccessWebTestCase extends DrupalWebTestCase {

  /**
   * Creates and returns a new access scheme with random properties.
   *
   * @return
   *   An access scheme.
   */
  function createScheme() {
    // Create a scheme.
    $scheme = new stdClass();
    $scheme->machine_name = drupal_strtolower($this->randomName());
    $scheme->name = $this->randomName();
    $scheme->realm_type = 'boolean';
    $scheme->description = $this->randomName();
    access_scheme_save($scheme);
    return $scheme;
  }

  /**
   * Creates and returns a new access grant for the given scheme.
   *
   * @param $scheme
   *   An access scheme.
   * @param $rid
   *   (optional) A role ID. If omitted, uses the first available scheme role.
   *   If no role is available, creates one using drupalCreateRole().
   * @param $account
   *   (optional) A user account. If omitted, uses drupalCreateUser().
   *
   * @return
   *   An access grant.
   */
  function createGrant($scheme, $rid = NULL, $account = NULL) {
    if (!isset($rid)) {
      $roles = variable_get('access_scheme_roles_' . $scheme->machine_name, array());
      if (empty($roles)) {
        $rid = $this->drupalCreateRole(array('access content'));
        $role = user_role_load($rid);
        $roles = array($rid => $role->name);
        variable_set('access_scheme_roles_' . $scheme->machine_name, $roles);
      }
      else {
        $rid = key($roles);
      }
    }
    if (!isset($account)) {
      $account = $this->drupalCreateUser(array('access content'));
    }
    $grant = new stdClass();
    $grant->rid = $rid;
    $grant->uid = $account->uid;
    $grant->scheme = $scheme->machine_name;
    access_grant_save($grant);
    return $grant;
  }

}

/**
 * Tests the access scheme interface.
 */
class AccessSchemeInterfaceTest extends AccessWebTestCase {

  protected $admin_user;
  protected $ack_role_rid;

  public static function getInfo() {
    return array(
      'name' => 'Access scheme interface',
      'description' => 'Tests the access scheme admin interface.',
      'group' => 'Access control kit',
    );
  }

  public function setUp() {
    // Enable the access control kit module.
    parent::setUp(array('access'));
    // Create and log in our admin user.
    $this->admin_user = $this->drupalCreateUser(array('administer access schemes'));
    $this->drupalLogin($this->admin_user);
    // Create a user role for use in the access scheme.
    $this->ack_role_rid = $this->drupalCreateRole(array('access content'));
  }

  /**
   * Create and edit an access scheme via the user interface.
   */
  function testSchemeInterface() {
    // Visit the scheme admin overview page.
    $this->drupalGet('admin/structure/access');

    // Create a new scheme through the admin form.
    $this->clickLink(t('Add access scheme'));
    $this->clickLink(t('Boolean'));
    $edit = array();
    $machine_name = drupal_strtolower($this->randomName());
    $edit['machine_name'] = $machine_name;
    $edit['name'] = $this->randomName();
    $edit['description'] = $this->randomName();
    $edit['roles[' . $this->ack_role_rid . ']'] = TRUE;
    $this->drupalPost(NULL, $edit, t('Save access scheme and continue'));
    $this->assertRaw(t('Added access scheme %name.', array('%name' => $edit['name'])), 'Scheme created successfully.');

    // Edit the scheme.
    $this->drupalGet('admin/structure/access');
    $this->assertText(t('@name (Machine name: @machine_name)', array('@name' => $edit['name'], '@machine_name' => $machine_name)), 'Scheme found in the scheme admin overview listing.');
    $this->clickLink(t('edit'));
    $edit = array();
    $edit['name'] = $this->randomName();
    $this->drupalPost(NULL, $edit, t('Save access scheme'));
    $this->assertText(t('@name (Machine name: @machine_name)', array('@name' => $edit['name'], '@machine_name' => $machine_name)), 'Updated scheme found in the scheme admin overview listing.');

    // Try to submit a new scheme with a duplicate human-readable name.
    $edit['machine_name'] = drupal_strtolower($this->randomName());
    $this->drupalPost('admin/structure/access/add/boolean', $edit, t('Save access scheme and continue'));
    $this->assertRaw(t('The name %name is already in use.', array('%name' => $edit['name'])));

    // Try to submit a new scheme with a duplicate machine name.
    $edit['name'] = $this->randomName();
    $edit['machine_name'] = $machine_name;
    $this->drupalPost('admin/structure/access/add/boolean', $edit, t('Save access scheme and continue'));
    $this->assertText(t('The machine-readable name is already in use. It must be unique.'));

    // Try to submit an invalid machine name.
    $edit['machine_name'] = '!&^%';
    $this->drupalPost('admin/structure/access/add/boolean', $edit, t('Save access scheme and continue'));
    $this->assertText(t('The machine-readable name must contain only lowercase letters, numbers, and underscores.'));

    // Try to submit a disallowed machine name.
    $edit['machine_name'] = 'add';
    $this->drupalPost('admin/structure/access/add/boolean', $edit, t('Save access scheme and continue'));
    $this->assertText(t('Invalid machine-readable name. Enter a name other than add.'));

    // Ensure that scheme names and descriptions are escaped properly.
    $edit = array();
    $description = '<strong>' . $this->randomName() . '</strong>';
    $edit['machine_name'] = 'don_t_panic';
    $edit['name'] = 'Don\'t Panic & Carry a Towel';
    $edit['description'] = '<script>' . $description . '</script>';
    $this->drupalPost('admin/structure/access/add/boolean', $edit, t('Save access scheme and continue'));
    // Check that the name isn't double-filtered when used as the page title.
    $site_name = variable_get('site_name', 'Drupal');
    $this->assertTitle(t('Don\'t Panic & Carry a Towel | @site-name', array('@site-name' => $site_name)));
    $this->assertNoTitle(t('Don&#039;t Panic &amp; Carry a Towel | @site-name', array('@site-name' => $site_name)));
    // Check that the name is sanitized in overview.
    $this->drupalGet('admin/structure/access');
    $this->assertRaw('Don&#039;t Panic &amp; Carry a Towel');
    $this->assertNoRaw($edit['name']);
    // Check that the description is sanitized in overview.
    $this->assertRaw($description);
    $this->assertNoRaw($edit['description']);
  }

  /**
   * Test the scheme overview with no schemes.
   */
  function testSchemeOverviewEmpty() {
    // Delete all schemes.
    $schemes = access_scheme_load_multiple(FALSE);
    foreach ($schemes as $sid => $scheme) {
      access_scheme_delete($sid);
    }
    // Confirm that no schemes remain in the database.
    $this->assertFalse(access_scheme_load_multiple(FALSE), 'No access schemes found in the database.');
    // Check the default message for no schemes.
    $this->drupalGet('admin/structure/access');
    $this->assertText(t('No access schemes available.'), 'No access schemes were found.');
  }

  /**
   * Delete an access scheme via the user interface.
   */
  function testSchemeDelete() {
    // Create an access scheme.
    $scheme = $this->createScheme();
    $scheme = access_scheme_load($scheme->sid, TRUE);
    $this->assertTrue($scheme, 'Access scheme found in the database.');

    // Create an access grant in the scheme.
    $grant = $this->createGrant($scheme);
    $grant = access_grant_load($grant->gid, TRUE);
    $this->assertTrue($grant, 'Access grant found in the database.');

    // Delete the scheme.
    $edit = array();
    $this->drupalPost('admin/structure/access/' . $scheme->machine_name, $edit, t('Delete access scheme'));
    $this->assertRaw(t('Are you sure you want to delete the access scheme %name?', array('%name' => $scheme->name)), '[confirm deletion] Asks for confirmation.');
    $this->assertRaw(t('All access grants within the scheme will also be deleted. %scheme currently contains 1 access grant on your site. If you remove this scheme, the user may not be able to exercise the permissions assigned by that grant.', array('%scheme' => $scheme->name)), '[confirm deletion] Informs that all grants will be deleted.');
    $this->assertText(t('This action cannot be undone.'), '[confirm deletion] Informs that deletion is permanent.');

    // Confirm deletion.
    $this->drupalPost(NULL, NULL, t('Delete'));
    $this->assertRaw(t('Deleted access scheme %name.', array('%name' => $scheme->name)), 'Access scheme deleted.');
    $this->assertFalse(access_grant_load($grant->gid, TRUE), 'Access grant is not found in the database.');
    $this->assertFalse(access_scheme_load($scheme->sid, TRUE), 'Access scheme is not found in the database.');
  }

}

/**
 * Tests for access scheme functions.
 */
class AccessSchemeFunctionTest extends AccessWebTestCase {

  protected $schemes;

  public static function getInfo() {
    return array(
      'name' => 'Access schemes',
      'description' => 'Tests loading, saving, and deleting access schemes.',
      'group' => 'Access control kit',
    );
  }

  public function setUp() {
    // Enable the access control kit module.
    parent::setUp(array('access'));
    // Create two schemes for testing.
    $this->schemes = array();
    $this->schemes[] = $this->createScheme();
    $this->schemes[] = $this->createScheme();
  }

  /**
   * Test basic create, read, update, and delete functions.
   */
  function testSchemeCRUD() {
    $loaded_schemes = access_scheme_load_multiple(FALSE, TRUE);
    $this->assertTrue(count($loaded_schemes), 'Access schemes exist in the database.');

    $i = 0;
    $count = count($this->schemes);
    $names = access_scheme_names();
    foreach ($this->schemes as $scheme) {
      $i++;
      // Find the test scheme in the name list.
      $this->assertTrue(isset($names[$scheme->machine_name]) && $names[$scheme->machine_name] == $scheme->name, "[scheme $i of $count] Found the scheme in the name list.");

      // Confirm that the loaded scheme matches expected values.
      $loaded_scheme = $loaded_schemes[$scheme->sid];
      $this->assertEqual($scheme->sid, $loaded_scheme->sid, "[scheme $i of $count] ID is OK.");
      $this->assertEqual($scheme->machine_name, $loaded_scheme->machine_name, "[scheme $i of $count] Machine name is OK.");
      $this->assertEqual($scheme->name, $loaded_scheme->name, "[scheme $i of $count] Human-readable name is OK.");
      $this->assertEqual($scheme->realm_type, $loaded_scheme->realm_type, "[scheme $i of $count] Realm type is OK.");
      $this->assertEqual($scheme->description, $loaded_scheme->description, "[scheme $i of $count] Description is OK.");

      // Confirm that the scheme's access realm field exists.
      $this->assertTrue(isset($loaded_scheme->realm_field) && isset($loaded_scheme->realm_field['field_name']) && $loaded_scheme->realm_field['field_name'] == _access_realm_field_name($scheme), "[scheme $i of $count] Realm field exists.");

      // Confirm that realm information was attached.
      $this->assertTrue(isset($loaded_scheme->realm_info) && isset($loaded_scheme->realm_info['realm_type']) && $loaded_scheme->realm_info['realm_type'] == 'boolean', "[scheme $i of $count] Realm info was attached.");
      $this->assertTrue(isset($loaded_scheme->realms) && is_array($loaded_scheme->realms) && ($loaded_scheme->realms[0] == t('False')) && ($loaded_scheme->realms[1] == t('True')), "[scheme $i of $count] Realm values were attached.");

      // Confirm that role information was attached.
      $this->assertTrue(isset($loaded_scheme->roles) && is_array($loaded_scheme->roles), "[scheme $i of $count] Roles were attached.");

      // Confirm that handlers were attached.
      $this->assertTrue(isset($loaded_scheme->handlers) && is_array($loaded_scheme->handlers), "[scheme $i of $count] Handlers were attached.");
    }

    // Attempt to load a scheme that doesn't exist.
    $sid = count($loaded_schemes) + 1;
    $scheme = access_scheme_load($sid);
    $this->assertFalse($scheme, 'Invalid scheme ID does not load.');
    // Create a new scheme, which should end up with $sid as its ID.
    $this->createScheme();
    // Make sure that the previously invalid ID now loads properly.
    $scheme = access_scheme_load($sid);
    $this->assertTrue(!empty($scheme) && is_object($scheme), 'Newly created access scheme loads properly.');
    $this->assertEqual($scheme->sid, $sid, 'Loaded scheme ID is the same as the previously invalid ID.');

    // Confirm that schemes can be loaded by machine name.
    $loaded_scheme = access_scheme_machine_name_load(str_replace('_', '-', $scheme->machine_name));
    $this->assertEqual($scheme->sid, $loaded_scheme->sid, 'Scheme loads by machine name.');

    // Confirm that the scheme can be updated.
    $loaded_scheme->name = $this->randomName();
    $this->assertEqual(access_scheme_save($loaded_scheme), SAVED_UPDATED, 'Scheme updated.');

    // Confirm that the scheme can be deleted.
    $this->assertEqual(access_scheme_delete($loaded_scheme->sid), SAVED_DELETED, 'Scheme deleted.');

    // Confirm that the scheme can be recreated.
    unset($loaded_scheme->sid);
    $this->assertEqual(access_scheme_save($loaded_scheme), SAVED_NEW, 'Scheme created.');
  }

  /**
   * Test deleting an access scheme that contains grants.
   */
  function testSchemeDeleteWithGrants() {
    $this->assertEqual(2, count($this->schemes));

    // Create five access grants each for the two test schemes.
    foreach ($this->schemes as $scheme) {
      // Assert that there are no existing grants for the access scheme.
      $this->assertEqual(0, db_query('SELECT COUNT(*) FROM {access_grant} WHERE scheme = :scheme', array(':scheme' => $scheme->machine_name))->fetchField());

      for ($i = 0; $i < 5; $i++) {
        $this->createGrant($scheme);
      }

      // Assert that there are now five grants for the access scheme.
      $this->assertEqual(5, db_query('SELECT COUNT(*) FROM {access_grant} WHERE scheme = :scheme', array(':scheme' => $scheme->machine_name))->fetchField());
    }

    // Delete the first scheme.
    $scheme = reset($this->schemes);
    access_scheme_delete($scheme->sid);

    // Assert that there are no grants left for the deleted scheme.
    $this->assertEqual(0, db_query('SELECT COUNT(*) FROM {access_grant} WHERE scheme = :scheme', array(':scheme' => $scheme->machine_name))->fetchField());

    // Assert that there are still five grants for the remaining scheme.
    $scheme = array_pop($this->schemes);
    $this->assertEqual(5, db_query('SELECT COUNT(*) FROM {access_grant} WHERE scheme = :scheme', array(':scheme' => $scheme->machine_name))->fetchField());
  }

  /**
   * Ensure that the access scheme static reset works correctly.
   */
  function testSchemeStaticReset() {
    $original_scheme = access_scheme_load($this->schemes[0]->sid);
    $this->assertTrue(is_object($original_scheme) && $original_scheme->name == $this->schemes[0]->name, 'Scheme loaded successfully.');

    // Change the name and description.
    $scheme = $original_scheme;
    $scheme->name = $this->randomName();
    $scheme->description = $this->randomName();
    access_scheme_save($scheme);

    // Load the scheme.
    $new_scheme = access_scheme_load($original_scheme->sid);
    $this->assertEqual($new_scheme->name, $scheme->name);
    $this->assertEqual($new_scheme->description, $scheme->description);

    // Delete the scheme.
    access_scheme_delete($this->schemes[0]->sid);
    $schemes = access_scheme_load_multiple(FALSE);
    $this->assertTrue(!isset($schemes[$this->schemes[0]->sid]), 'The scheme was deleted.');
  }

}
