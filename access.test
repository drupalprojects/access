<?php

/**
 * @file
 * Tests for the access control kit module.
 */

/**
 * Provides common helper methods for access control kit module tests.
 */
class AccessWebTestCase extends DrupalWebTestCase {

  /**
   * Creates and returns a new access scheme with random properties.
   *
   * @return
   *   An access scheme.
   */
  function createScheme() {
    // Create a scheme.
    $scheme = new stdClass();
    $scheme->machine_name = drupal_strtolower($this->randomName());
    $scheme->name = $this->randomName();
    $scheme->type = 'boolean';
    $scheme->description = $this->randomName();
    access_scheme_save($scheme);
    return $scheme;
  }

  /**
   * Creates and returns a new access grant for the given scheme.
   *
   * @param $scheme
   *   An access scheme.
   * @param $role
   *   (optional) A user role. If omitted, uses the first available scheme role.
   *   If no role is available, creates one using drupalCreateRole().
   * @param $account
   *   (optional) A user account. If omitted, uses drupalCreateUser() and adds
   *   the user to the role.
   *
   * @return
   *   An access grant.
   */
  function createGrant($scheme, $role = NULL, $account = NULL) {
    // Make sure we have a user role to assign.
    if (!isset($role)) {
      // Get the list of roles enabled for this scheme.
      $scheme_roles = variable_get('access_scheme_roles_' . $scheme->machine_name, array());
      // If the scheme has no enabled roles, create one for it.
      if (empty($scheme_roles)) {
        $rid = $this->drupalCreateRole(array('access content'));
        $role = user_role_load($rid);
        $scheme_roles = array($role->rid => $role->name);
        variable_set('access_scheme_roles_' . $scheme->machine_name, $scheme_roles);
      }
      // Otherwise, use the first enabled role.
      else {
        $rid = key($scheme_roles);
        $role = user_role_load($rid);
      }
    }

    // Make sure we have a user to assign.
    if (!isset($account)) {
      // Create an account and add it to the role.
      $account = $this->drupalCreateUser(array('access content'));
      $account->original = clone $account;
      $user_roles = $account->roles + array($role->rid => $role->name);
      user_save($account, array('roles' => $user_roles));
    }

    // Create an access grant.
    $grant = entity_get_controller('access_grant')->create(array('scheme' => $scheme->machine_name));
    $grant->rid = $role->rid;
    $grant->uid = $account->uid;
    access_grant_save($grant);
    return $grant;
  }

}

/**
 * Tests the access scheme interface.
 */
class AccessSchemeInterfaceTest extends AccessWebTestCase {

  protected $admin_user;
  protected $ack_role_rid;

  /**
   * Implements getInfo(), required method for SimpleTest.
   */
  public static function getInfo() {
    return array(
      'name' => 'Access scheme interface',
      'description' => 'Tests the access scheme admin interface.',
      'group' => 'Access control kit',
    );
  }

  /**
   * Overrides DrupalWebTestCase::setUp().
   */
  public function setUp() {
    // Enable the access control kit module.
    parent::setUp(array('access'));
    // Create and log in our admin user.
    $this->admin_user = $this->drupalCreateUser(array('administer access schemes'));
    $this->drupalLogin($this->admin_user);
    // Create a user role for use in the access scheme.
    $this->ack_role_rid = $this->drupalCreateRole(array('access content'));
  }

  /**
   * Create and edit an access scheme via the user interface.
   */
  function testSchemeInterface() {
    // Visit the scheme admin overview page.
    $this->drupalGet('admin/structure/access');

    // Create a new scheme through the admin form.
    $this->clickLink(t('Add access scheme'));
    $this->clickLink(t('Boolean'));
    $this->assertText(t('Add access scheme: @type', array('@type' => t('Boolean'))));
    $edit = array();
    $machine_name = drupal_strtolower($this->randomName());
    $edit['machine_name'] = $machine_name;
    $edit['name'] = $this->randomName();
    $edit['description'] = $this->randomName();
    $edit['roles[' . $this->ack_role_rid . ']'] = TRUE;
    $this->drupalPost(NULL, $edit, t('Save access scheme and continue'));
    $this->assertRaw(t('Added access scheme %name.', array('%name' => $edit['name'])), 'Scheme created successfully.');
    $this->drupalGet('admin/structure/access');
    $this->assertText(t('@name (Machine name: @machine_name)', array('@name' => $edit['name'], '@machine_name' => $machine_name)), 'Scheme found in the scheme admin overview listing.');

    // Edit the scheme.
    $this->clickLink(t('edit'));
    $machine_name_disabled = $this->xpath('//input[@id=:id and @disabled="disabled"]', array(':id' => 'edit-machine-name'));
    $this->assertTrue($machine_name_disabled, 'The machine name cannot be changed.');
    $this->assertText(t('No access-controllable objects available.'), 'Informs that no access-controllable object types have been defined.');
    $edit = array();
    $edit['name'] = $this->randomName();
    $this->drupalPost(NULL, $edit, t('Save access scheme'));
    $this->assertRaw(t('Updated access scheme %name.', array('%name' => $edit['name'])), 'Scheme updated successfully.');
    $this->assertText(t('@name (Machine name: @machine_name)', array('@name' => $edit['name'], '@machine_name' => $machine_name)), 'Updated scheme found in the scheme admin overview listing.');

    // Check integration with the Field UI.
    $this->clickLink(t('manage fields'));
    $this->assertText(t('Manage fields'));
    $this->assertText(t('Access control kit user reference'));
    $this->assertText(t('Access control kit role reference'));
    $this->assertText('ack_' . $machine_name);
    $this->drupalGet('admin/structure/access');
    $this->clickLink(t('manage display'));
    $this->assertText(t('Manage display'));
    $this->assertText(t('User'));
    $this->assertText(t('Role'));

    // Try to submit a new scheme with a duplicate human-readable name.
    $edit['machine_name'] = drupal_strtolower($this->randomName());
    $this->drupalPost('admin/structure/access/add/boolean', $edit, t('Save access scheme and continue'));
    $this->assertRaw(t('The name %name is already in use.', array('%name' => $edit['name'])));

    // Try to submit a new scheme with a duplicate machine name.
    $edit['name'] = $this->randomName();
    $edit['machine_name'] = $machine_name;
    $this->drupalPost('admin/structure/access/add/boolean', $edit, t('Save access scheme and continue'));
    $this->assertText(t('The machine-readable name is already in use. It must be unique.'));

    // Try to submit an invalid machine name.
    $edit['machine_name'] = '!&^%';
    $this->drupalPost('admin/structure/access/add/boolean', $edit, t('Save access scheme and continue'));
    $this->assertText(t('The machine-readable name must contain only lowercase letters, numbers, and underscores.'));

    // Try to submit a disallowed machine name.
    $edit['machine_name'] = 'add';
    $this->drupalPost('admin/structure/access/add/boolean', $edit, t('Save access scheme and continue'));
    $this->assertText(t('Invalid machine-readable name. Enter a name other than add.'));

    // Ensure that scheme names and descriptions are escaped properly.
    $edit = array();
    $description = '<strong>' . $this->randomName() . '</strong>';
    $edit['machine_name'] = 'don_t_panic';
    $edit['name'] = 'Don\'t Panic & Carry a Towel';
    $edit['description'] = '<script>' . $description . '</script>';
    $this->drupalPost('admin/structure/access/add/boolean', $edit, t('Save access scheme and continue'));
    // Check that the name isn't double-filtered when used as the page title.
    $site_name = variable_get('site_name', 'Drupal');
    $this->assertTitle(t('Don\'t Panic & Carry a Towel | @site-name', array('@site-name' => $site_name)));
    $this->assertNoTitle(t('Don&#039;t Panic &amp; Carry a Towel | @site-name', array('@site-name' => $site_name)));
    // Check that the name is sanitized in overview.
    $this->drupalGet('admin/structure/access');
    $this->assertRaw('Don&#039;t Panic &amp; Carry a Towel');
    $this->assertNoRaw($edit['name']);
    // Check that the description is sanitized in overview.
    $this->assertRaw($description);
    $this->assertNoRaw($edit['description']);
  }

  /**
   * Confirm that realm fields are hidden from the scheme UI and Field UI.
   */
  function testSchemeRealmFieldsHidden() {
    // Confirm that we're starting clean.
    $this->drupalGet('admin/structure/access/add');
    $this->assertNoText(t('List (integer) field'), 'The list (integer) scheme type is not available.');

    // Create a user account scheme, which uses a list_integer realm field.
    $edit = array();
    $machine_name = drupal_strtolower($this->randomName());
    $edit['machine_name'] = $machine_name;
    $edit['name'] = $this->randomName();
    $this->drupalPost('admin/structure/access/add/user', $edit, t('Save access scheme and continue'));
    $this->drupalGet('admin/structure/access');
    $this->assertText(t('@name (Machine name: @machine_name)', array('@name' => $edit['name'], '@machine_name' => $machine_name)), 'Scheme found in the scheme admin overview listing.');

    // Confirm that realm fields cannot be deleted through the Field UI.
    $this->drupalGet('admin/structure/access/' . $machine_name . '/fields/ack_' . $machine_name . '/delete');
    $this->assertText(t('This field is locked and cannot be deleted.'), 'Realm fields are locked.');

    // Confirm that the presence of a scheme with a list_integer realm field
    // does not make the list_integer scheme type available.
    $this->drupalGet('admin/structure/access/add');
    $this->assertNoText(t('List (integer) field'), 'Realm fields are ignored when determining whether a list-based scheme can be created.');

    // Create a valid list_integer field and confirm that the scheme type does
    // become available.
    $field = array(
      'field_name' => 'field_valid_list',
      'type' => 'list_integer',
    );
    field_create_field($field);
    $this->drupalGet('admin/structure/access/add');
    $this->assertText(t('List (integer) field'), 'List-based schemes become available when usable fields are present.');

    // Confirm that the scheme's realm field is hidden from the scheme UI.
    $this->clickLink(t('List (integer) field'));
    $this->assertNoRaw('ack_' . $machine_name, 'Realm fields are hidden when selecting the base field for a list-based scheme.');
    $this->assertRaw($field['field_name'], 'Usable list fields are selectable on a list-based scheme.');

    // Confirm that realm fields are hidden from the Field UI.
    $scheme = $this->createScheme();
    $this->drupalGet('admin/structure/access/' . $scheme->machine_name . '/fields');
    $this->assertNoRaw('ack_' . $machine_name, 'Realm fields are hidden from the Field UI.');
  }

  /**
   * Test the scheme overview with no schemes.
   */
  function testSchemeOverviewEmpty() {
    // Delete all schemes.
    $schemes = access_scheme_load_multiple(FALSE);
    foreach ($schemes as $sid => $scheme) {
      access_scheme_delete($sid);
    }
    // Confirm that no schemes remain in the database.
    $this->assertFalse(access_scheme_load_multiple(FALSE), 'No access schemes found in the database.');
    // Check the default message for no schemes.
    $this->drupalGet('admin/structure/access');
    $this->assertText(t('No access schemes available.'), 'No access schemes were found.');
  }

  /**
   * Delete an access scheme via the user interface.
   */
  function testSchemeDelete() {
    // Create an access scheme.
    $scheme = $this->createScheme();
    $scheme = access_scheme_load($scheme->sid, TRUE);
    $this->assertTrue($scheme, 'Access scheme found in the database.');

    // Create an access grant in the scheme.
    $grant = $this->createGrant($scheme);
    $grant = access_grant_load($grant->gid, TRUE);
    $this->assertTrue($grant, 'Access grant found in the database.');

    // Check deleting from the overview page.
    $this->drupalGet('admin/structure/access');
    $this->clickLink(t('delete'));
    $this->assertRaw(t('Are you sure you want to delete the access scheme %name?', array('%name' => $scheme->name)), '[confirm deletion] Asks for confirmation.');

    // Delete the scheme.
    $edit = array();
    $this->drupalPost('admin/structure/access/' . $scheme->machine_name, $edit, t('Delete access scheme'));
    $this->assertRaw(t('Are you sure you want to delete the access scheme %name?', array('%name' => $scheme->name)), '[confirm deletion] Asks for confirmation.');
    $this->assertRaw(t('All access grants within the scheme will also be deleted. %scheme currently contains 1 access grant on your site. If you remove this scheme, the user may not be able to exercise the permissions assigned by that grant.', array('%scheme' => $scheme->name)), '[confirm deletion] Informs that all grants will be deleted.');
    $this->assertText(t('This action cannot be undone.'), '[confirm deletion] Informs that deletion is permanent.');

    // Confirm deletion.
    $this->drupalPost(NULL, NULL, t('Delete'));
    $this->assertRaw(t('Deleted access scheme %name.', array('%name' => $scheme->name)), 'Access scheme deleted.');
    $this->assertFalse(access_grant_load($grant->gid, TRUE), 'Access grant is not found in the database.');
    $this->assertFalse(access_scheme_load($scheme->sid, TRUE), 'Access scheme is not found in the database.');
  }

}

/**
 * Tests for access scheme functions.
 */
class AccessSchemeFunctionTest extends AccessWebTestCase {

  protected $schemes;

  /**
   * Implements getInfo(), required method for SimpleTest.
   */
  public static function getInfo() {
    return array(
      'name' => 'Access schemes',
      'description' => 'Tests loading, saving and deleting access schemes.',
      'group' => 'Access control kit',
    );
  }

  /**
   * Overrides DrupalWebTestCase::setUp().
   */
  public function setUp() {
    // Enable the access control kit module.
    parent::setUp(array('access'));
    // Create two schemes for testing.
    $this->schemes = array();
    $this->schemes[] = $this->createScheme();
    $this->schemes[] = $this->createScheme();
  }

  /**
   * Test basic create, read, update, and delete functions.
   */
  function testSchemeCRUD() {
    $loaded_schemes = access_scheme_load_multiple(FALSE, TRUE);
    $this->assertTrue(count($loaded_schemes), 'Access schemes exist in the database.');

    $i = 0;
    $count = count($this->schemes);
    $names = access_scheme_names();
    foreach ($this->schemes as $scheme) {
      $i++;
      // Find the test scheme in the name list.
      $this->assertTrue(isset($names[$scheme->machine_name]) && $names[$scheme->machine_name] == $scheme->name, "[scheme $i of $count] Found the scheme in the name list.");

      // Confirm that the loaded scheme matches expected values.
      $loaded_scheme = $loaded_schemes[$scheme->sid];
      $this->assertEqual($scheme->sid, $loaded_scheme->sid, "[scheme $i of $count] ID is OK.");
      $this->assertEqual($scheme->machine_name, $loaded_scheme->machine_name, "[scheme $i of $count] Machine name is OK.");
      $this->assertEqual($scheme->name, $loaded_scheme->name, "[scheme $i of $count] Human-readable name is OK.");
      $this->assertEqual($scheme->type, $loaded_scheme->type, "[scheme $i of $count] Scheme type is OK.");
      $this->assertEqual($scheme->description, $loaded_scheme->description, "[scheme $i of $count] Description is OK.");

      // Confirm that the scheme's access realm field exists.
      $this->assertTrue(isset($loaded_scheme->realm_field) && isset($loaded_scheme->realm_field['field_name']) && $loaded_scheme->realm_field['field_name'] == _access_realm_field_name($scheme), "[scheme $i of $count] Realm field exists.");

      // Confirm that scheme type and realm information were attached.
      $this->assertTrue(isset($loaded_scheme->info) && isset($loaded_scheme->info['type']) && $loaded_scheme->info['type'] == 'boolean', "[scheme $i of $count] Scheme type info was attached.");
      $this->assertTrue(isset($loaded_scheme->realms) && is_array($loaded_scheme->realms) && ($loaded_scheme->realms[0] == t('False')) && ($loaded_scheme->realms[1] == t('True')), "[scheme $i of $count] Realm values were attached.");

      // Confirm that role information was attached.
      $this->assertTrue(isset($loaded_scheme->roles) && is_array($loaded_scheme->roles), "[scheme $i of $count] Roles were attached.");

      // Confirm that handlers were attached.
      $this->assertTrue(isset($loaded_scheme->handlers) && is_array($loaded_scheme->handlers), "[scheme $i of $count] Handlers were attached.");
    }

    // Attempt to load a scheme that doesn't exist.
    $sid = count($loaded_schemes) + 1;
    $scheme = access_scheme_load($sid);
    $this->assertFalse($scheme, 'Invalid scheme ID does not load.');
    // Create a new scheme, which should end up with $sid as its ID.
    $this->createScheme();
    // Make sure that the previously invalid ID now loads properly.
    $scheme = access_scheme_load($sid);
    $this->assertTrue(!empty($scheme) && is_object($scheme), 'Newly created access scheme loads properly.');
    $this->assertEqual($scheme->sid, $sid, 'Loaded scheme ID is the same as the previously invalid ID.');

    // Confirm that schemes can be loaded by machine name.
    $loaded_scheme = access_scheme_machine_name_load(str_replace('_', '-', $scheme->machine_name));
    $this->assertEqual($scheme->sid, $loaded_scheme->sid, 'Scheme loads by machine name.');

    // Confirm that the scheme can be updated.
    $loaded_scheme->name = $this->randomName();
    $this->assertEqual(access_scheme_save($loaded_scheme), SAVED_UPDATED, 'Scheme updated.');

    // Confirm that the scheme can be deleted.
    $this->assertEqual(access_scheme_delete($loaded_scheme->sid), SAVED_DELETED, 'Scheme deleted.');

    // Confirm that the scheme can be recreated.
    unset($loaded_scheme->sid);
    $this->assertEqual(access_scheme_save($loaded_scheme), SAVED_NEW, 'Scheme created.');
  }

  /**
   * Test deleting an access scheme that contains grants.
   */
  function testSchemeDeleteWithGrants() {
    $this->assertEqual(2, count($this->schemes));

    // Create five access grants each for the two test schemes.
    foreach ($this->schemes as $scheme) {
      // Assert that there are no existing grants for the access scheme.
      $this->assertEqual(0, db_query('SELECT COUNT(*) FROM {access_grant} WHERE scheme = :scheme', array(':scheme' => $scheme->machine_name))->fetchField());

      for ($i = 0; $i < 5; $i++) {
        $this->createGrant($scheme);
      }

      // Assert that there are now five grants for the access scheme.
      $this->assertEqual(5, db_query('SELECT COUNT(*) FROM {access_grant} WHERE scheme = :scheme', array(':scheme' => $scheme->machine_name))->fetchField());
    }

    // Delete the first scheme.
    $scheme = reset($this->schemes);
    access_scheme_delete($scheme->sid);

    // Assert that there are no grants left for the deleted scheme.
    $this->assertEqual(0, db_query('SELECT COUNT(*) FROM {access_grant} WHERE scheme = :scheme', array(':scheme' => $scheme->machine_name))->fetchField());

    // Assert that there are still five grants for the remaining scheme.
    $scheme = array_pop($this->schemes);
    $this->assertEqual(5, db_query('SELECT COUNT(*) FROM {access_grant} WHERE scheme = :scheme', array(':scheme' => $scheme->machine_name))->fetchField());
  }

  /**
   * Ensure that the access scheme static reset works correctly.
   */
  function testSchemeStaticReset() {
    $original_scheme = access_scheme_load($this->schemes[0]->sid);
    $this->assertTrue(is_object($original_scheme) && $original_scheme->name == $this->schemes[0]->name, 'Scheme loaded successfully.');

    // Change the name and description.
    $scheme = $original_scheme;
    $scheme->name = $this->randomName();
    $scheme->description = $this->randomName();
    access_scheme_save($scheme);

    // Load the scheme.
    $new_scheme = access_scheme_load($original_scheme->sid);
    $this->assertEqual($new_scheme->name, $scheme->name);
    $this->assertEqual($new_scheme->description, $scheme->description);

    // Delete the scheme.
    access_scheme_delete($this->schemes[0]->sid);
    $schemes = access_scheme_load_multiple(FALSE);
    $this->assertTrue(!isset($schemes[$this->schemes[0]->sid]), 'The scheme was deleted.');
  }

}

/**
 * Tests the access grant interface.
 */
class AccessGrantInterfaceTest extends AccessWebTestCase {

  protected $admin_user;
  protected $ack_role;
  protected $ack_user;

  /**
   * Implements getInfo(), required method for SimpleTest.
   */
  public static function getInfo() {
    return array(
      'name' => 'Access grant interface',
      'description' => 'Tests the access grant admin interface.',
      'group' => 'Access control kit',
    );
  }

  /**
   * Overrides DrupalWebTestCase::setUp().
   */
  public function setUp() {
    // Enable the access control kit module.
    parent::setUp(array('access'));
    // Create and log in our admin user.
    $this->admin_user = $this->drupalCreateUser(array('administer access grants'));
    $this->drupalLogin($this->admin_user);
    // Create a user role for use in an access scheme.
    $rid = $this->drupalCreateRole(array('access content'));
    $this->ack_role = user_role_load($rid);
    // Create a user account for use in access grants.
    $this->ack_user = $this->drupalCreateUser(array('access content'));
  }

  /**
   * Create and edit an access grant via the user interface.
   */
  function testGrantInterface() {
    // Visit the grant admin overview page.
    $this->drupalGet('admin/access');

    // Check that the add grant page responds to the presence of access schemes.
    $this->clickLink(t('Add access grant'));
    $this->assertText(t('You have not created any access schemes yet.'), 'Informs that an access scheme must exist before grants can be created.');
    $scheme = $this->createScheme();
    $this->drupalGet('admin/access/add');
    $this->assertNoLink(check_plain($scheme->name), 'The "add grant" list page is bypassed when only one scheme exists.');
    $this->assertText(t('Grant access to @name', array('@name' => $scheme->name)));
    $deleted_scheme = $this->createScheme();
    $this->drupalGet('admin/access/add');
    $this->assertLink(check_plain($scheme->name), 0, 'The "add grant" list page is shown when more than one scheme exists.');
    $this->clickLink(check_plain($deleted_scheme->name));
    $this->assertText(t('Grant access to @name', array('@name' => $deleted_scheme->name)));
    access_scheme_delete($deleted_scheme->sid);
    $this->drupalGet('admin/access/add');
    $this->assertNoLink(check_plain($deleted_scheme->name), 'Deleted schemes are not shown when adding a grant.');

    // Set the scheme to use the test role.
    $this->assertText(t('No roles are available for new access grants.'));
    $scheme = access_scheme_load($scheme->sid);
    $scheme->roles = array($this->ack_role->rid => $this->ack_role->name);
    variable_set('access_scheme_roles_' . $scheme->machine_name, $scheme->roles);
    $this->drupalGet('admin/access/add');
    $this->assertNoText(t('No roles are available for new access grants.'));

    // Attempt to create an access grant through the admin form for a role that
    // the test user does not yet have.
    $this->assertText(t('Grant access to @name', array('@name' => $scheme->name)));
    $edit = array();
    $edit['user'] = $this->ack_user->name;
    $edit['role'] = $this->ack_role->rid;
    $field_name = $scheme->realm_field['field_name'];
    $edit[$field_name . '[und][1]'] = TRUE;
    $this->drupalPost(NULL, $edit, t('Save'));
    $this->assertText(t('@user is not a member of the @role role.', array('@user' => $this->ack_user->name, '@role' => $this->ack_role->name)), 'Cannot add users to roles without access to administer users.');

    // Give the admin user access to grant new roles and try again.
    $this->admin_user->original = clone $this->admin_user;
    $rid = $this->drupalCreateRole(array('administer users'));
    $role = user_role_load($rid);
    $roles = $this->admin_user->roles + array($role->rid => $role->name);
    user_save($this->admin_user, array('roles' => $roles));
    $this->drupalGet('admin/access/add');
    $this->assertText(t('The user will be added to this role, if not already a member.'), 'User administrators are notified that they can add new roles.');
    $this->drupalPost(NULL, $edit, t('Save'));
    $this->assertRaw(t("Added %scheme for %user's access as %role.", array('%scheme' => $scheme->name, '%user' => $this->ack_user->name, '%role' => $this->ack_role->name)), 'Grant created successfully.');
    $this->drupalGet('admin/access');
    // Check that all grant fields are correctly shown in the overview.
    $this->assertText(check_plain($this->ack_user->name), 'Grant found in the grant admin overview listing.');
    $this->assertText(check_plain($this->ack_role->name));
    $this->assertText(t('True'));
    $this->assertText(check_plain($scheme->name));

    // View the grant.
    $this->clickLink(t('view'));
    $this->assertRaw(t("@user&#039;s access as @role", array('@user' => $this->ack_user->name, '@role' => $this->ack_role->name)), 'Grant can be rendered.');
    $this->assertText(check_plain($this->ack_user->name));
    $this->assertText(check_plain($this->ack_role->name));
    $this->assertText(t('True'));
    $this->assertText(check_plain($scheme->name));

    // Edit the grant.
    $this->clickLink(t('Edit'));
    $this->assertRaw('<label for="edit-user-display">User </label>', 'User field is display only.');
    $this->assertRaw('<label for="edit-role-display">Role </label>', 'Role field is display only.');
    $edit = array();
    $edit[$field_name . '[und][0]'] = TRUE;
    $edit[$field_name . '[und][1]'] = FALSE;
    $this->drupalPost(NULL, $edit, t('Save'));
    $this->assertRaw(t("Updated %scheme for %user's access as %role.", array('%scheme' => $scheme->name, '%user' => $this->ack_user->name, '%role' => $this->ack_role->name)), 'Grant updated successfully.');
    $this->assertFieldChecked('edit-' . strtr($field_name, '_', '-') . '-und-0', 'New realm assigned.');
    $this->assertNoFieldChecked('edit-' . strtr($field_name, '_', '-') . '-und-1', 'Old realm removed.');
    $this->drupalGet('admin/access');
    $this->assertText(t('False'), 'Updated grant found in the grant admin overview listing.');
    $this->assertNoText(t('True'));

    // Try to submit a duplicate grant for this user-role-scheme combination.
    $this->drupalGet('admin/access/add');
    $edit = array();
    $edit['user'] = $this->ack_user->name;
    $edit['role'] = $this->ack_role->rid;
    $field_name = $scheme->realm_field['field_name'];
    $edit[$field_name . '[und][1]'] = TRUE;
    $this->drupalPost(NULL, $edit, t('Save'));
    $this->assertRaw(t('%user has already been granted access as %role in @scheme.', array('@scheme' => $scheme->name, '%user' => $this->ack_user->name, '%role' => $this->ack_role->name)), 'Duplicate access grants are not permitted.');

    // Create a user with an unsafe username.
    $new_user = $this->drupalCreateUser();
    $new_user->name = 'Don\'t';
    user_save($new_user);
    $new_user = user_load($new_user->uid, TRUE);
    // Create a role with an unsafe name.
    $new_rid = $this->drupalCreateRole(array('access content'));
    $new_role = user_role_load($new_rid);
    $new_role->name = 'Panic & Carry';
    user_role_save($new_role);
    $new_role = user_role_load($new_role->rid);
    // Create a scheme with an unsafe name.
    $new_scheme = $this->createScheme();
    $new_scheme = access_scheme_load($new_scheme->sid);
    $new_scheme->roles = array($new_role->rid => $new_role->name);
    variable_set('access_scheme_roles_' . $new_scheme->machine_name, $new_scheme->roles);
    $new_scheme_name = 'a Towel';
    $new_scheme->name = '<script>' . $new_scheme_name . '</script>';
    access_scheme_save($new_scheme);
    $new_scheme = access_scheme_load($new_scheme->sid, TRUE);
    // Create a grant with the unsafe values.
    $new_grant = $this->createGrant($new_scheme, $new_role, $new_user);
    $field_name = $new_scheme->realm_field['field_name'];
    $new_grant->$field_name = array('und' => array(array('value' => 1)));
    access_grant_save($new_grant);
    // Ensure that grant values are escaped properly in displays.
    for ($i = 0; $i < 2; $i++) {
      switch ($i) {
        case 0:
          // Overview.
          $this->drupalGet('admin/access');
          // Check the scheme name.
          $this->assertRaw('&lt;script&gt;a Towel&lt;/script&gt;');
          $this->assertNoRaw($new_scheme->name);
          break;

        case 1:
          // Rendered view.
          $this->drupalGet('admin/access/grant/' . $new_grant->gid);
          // Check that the name isn't double-filtered in the page title.
          $site_name = variable_get('site_name', 'Drupal');
          $this->assertTitle(t('Don\'t\'s access as Panic & Carry | @site-name', array('@site-name' => $site_name)));
          $this->assertNoTitle(t('Don&#039;t\'s access as Panic &amp; Carry | @site-name', array('@site-name' => $site_name)));
          break;
      }
      // Checks common to all displays.
      $this->assertRaw('Don&#039;t');
      $this->assertNoRaw($new_user->name);
      $this->assertRaw('Panic &amp; Carry');
      $this->assertNoRaw($new_role->name);
    }
  }

}

/**
 * Tests the access control kit API.
 */
class AccessAPITest extends AccessWebTestCase {

  protected $ack_role;
  protected $scheme;

  /**
   * Implements getInfo(), required method for SimpleTest.
   */
  public static function getInfo() {
    return array(
      'name' => 'Access control kit API',
      'description' => 'Tests the access control kit API and handler interface.',
      'group' => 'Access control kit',
    );
  }

  /**
   * Overrides DrupalWebTestCase::setUp().
   */
  public function setUp() {
    // Enable the access control kit module and our dummy test module.
    parent::setUp(array('access', 'access_test'));
    // Create a role that uses the permission defined in access_test.module.
    $rid = $this->drupalCreateRole(array('meow'));
    $this->ack_role = user_role_load($rid);
    // Create an access scheme that uses the test role.
    $scheme = $this->createScheme();
    $scheme->roles = array($this->ack_role->rid => $this->ack_role->name);
    variable_set('access_scheme_roles_' . $scheme->machine_name, $scheme->roles);
    $this->scheme = $scheme;
  }

  /**
   * Attach a handler to the test scheme through the UI, checking that the ACK
   * hooks and their alter hooks fire correctly as we go.
   */
  function testHandlerInterface() {
    // Create and log in an admin user.
    $admin_user = $this->drupalCreateUser(array('administer access schemes'));
    $this->drupalLogin($admin_user);

    // Go to the "add access scheme" page and check that the boolean scheme type
    // label was successfully altered.
    $this->drupalGet('admin/structure/access/add');
    $this->assertNoText(t('Boolean'), 'hook_access_scheme_info_alter(): The boolean scheme type info was changed.');
    $this->clickLink(t('Yes or no'));

    // Check that the settings callback fired.
    $this->assertText(t('The scheme does not have grants.'), 'Scheme settings callback was called.');

    // Check that the access-controllable object types and handlers were
    // successfully registered and altered.
    $this->drupalGet('admin/structure/access/' . $this->scheme->machine_name);
    $this->assertText(t('@object_type access realms are determined by', array('@object_type' => t('Cat'))), 'hook_access_info(): The object type was registered.');
    $this->assertNoText(t('Kitten'), 'hook_access_info_alter(): The access-controllable object type info was changed.');
    $this->assertRaw('<option value="ACKTestMeowHandler">', 'hook_access_handler_info(): The handler was registered.');
    $this->assertText(t('@object_type access realms are determined by', array('@object_type' => t('Dog'))), 'hook_access_handler_info_alter(): The supported object types for the handler were changed.');
    $this->assertText(t('No object access handlers are available to manage @object_type objects in a @scheme_type scheme.', array('@object_type' => t('Bird'), '@scheme_type' => t('Yes or no'))), 'The handler UI notifies the user when there are no available handlers.');

    // Attach the handler and confirm that the attachment was saved.
    $edit = array('handlers[cat][handler]' => 'ACKTestMeowHandler');
    $this->drupalPost(NULL, $edit, t('Save access scheme'));
    $this->clickLink(t('edit'));
    $this->assertOptionSelected('edit-handlers-cat-handler', 'ACKTestMeowHandler', 'The handler was attached to the correct object type.');
    $this->assertNoOptionSelected('edit-handlers-dog-handler', 'ACKTestMeowHandler', 'The handler was not attached to the incorrect object type.');
    $this->assertText(t('The meow handler assigns the boolean TRUE realm to cats and the boolean FALSE realm to everything else.'), 'The handler description was displayed.');
    $this->assertText(t('Meow handler settings would go here.'), 'The handler settings method was called.');

    // Detach the handler and confirm that the attachment was deleted.
    $edit = array('handlers[cat][handler]' => '');
    $this->drupalPost(NULL, $edit, t('Save access scheme'));
    $this->clickLink(t('edit'));
    $this->assertNoOptionSelected('edit-handlers-cat-handler', 'ACKTestMeowHandler', 'The handler was detached.');

    // Check that the scheme settings form changes when grants are present.
    $this->createGrant($this->scheme, $this->ack_role);
    $this->drupalGet('admin/structure/access/' . $this->scheme->machine_name);
    $this->assertText(t('The scheme has grants.'), 'Scheme form detects existing grants.');
  }

  /**
   * Test access arbitration through our dummy handler.
   */
   function testHandlerMethods() {
     $dummy_object = new stdClass();

     // Attach the test "meow" handler for dummy "cat" and "dog" object types.
     access_handler_save($this->scheme, 'cat', 'ACKTestMeowHandler', 'access_test');
     access_handler_save($this->scheme, 'dog', 'ACKTestMeowHandler', 'access_test');
     // Reset the scheme cache.
     $this->scheme = access_scheme_load($this->scheme->sid, TRUE);

     // Create an access grant in the scheme for a test user.
     $grant = $this->createGrant($this->scheme, $this->ack_role);
     // Assign access in the TRUE realm.
     $fieldname = _access_realm_field_name($this->scheme);
     $grant->$fieldname = array(LANGUAGE_NONE => array(array('value' => TRUE)));
     access_grant_save($grant);
     // Reset grant cache.
     access_grant_load($grant->gid, TRUE);

     // Get the test user.
     $test_user = user_load($grant->uid, TRUE);

     // Check access.
     $this->assertTrue(access_user_object_access('meow', 'cat', $dummy_object, $test_user), 'User has access to an object in an assigned realm.');
     $this->assertFalse(access_user_object_access('meow', 'dog', $dummy_object, $test_user), 'User does not have access to an object in an unassigned realm.');
   }

}
