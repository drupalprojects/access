<?php
/**
 * @file
 * The access control kit module.
 */

/**
 * Implements hook_entity_info().
 */
function access_entity_info() {
  // Access grants.
  $types['access_grant'] = array(
    'label' => t('Access grant'),
    'controller class' => 'AccessGrantEntityController',
    'base table' => 'access_grant',
    'uri callback' => 'access_grant_uri',
    'label callback' => 'access_grant_label',
    'fieldable' => TRUE,
    'entity keys' => array(
      'id' => 'gid',
      'bundle' => 'scheme',
    ),
    'bundle keys' => array(
      'bundle' => 'scheme',
    ),
    'bundles' => array(),
    'view modes' => array(
      'full' => array(
        'label' => t('Access grant page'),
        'custom settings' => FALSE,
      ),
    ),
  );

  // Bundles are access schemes; the access realm field in the bundle determines
  // which objects are accessible to a user via an access grant.
  foreach (access_scheme_get_names() as $scheme => $name) {
    $types['access_grant']['bundles'][$scheme] = array(
      'label' => $name,
      'admin' => array(
        'path' => 'admin/structure/access/manage/%access_scheme',
        'real path' => 'admin/structure/access/manage/' . str_replace('_', '-', $scheme),
        'bundle argument' => 4,
        'access arguments' => array('administer access schemes'),
      ),
    );
  }

  return $types;
}

/**
 * Entity URI callback for an access grant.
 */
function access_grant_uri($grant) {
  return array('path' => 'admin/access/grant/' . $grant->gid);
}

/**
 * Entity label callback for an access grant.
 */
function access_grant_label($grant) {
  // Load the primary descriptors of the grant.
  $account = user_load($grant->uid);
  $role = user_role_load($grant->rid);

  // Sanitize the descriptors.
  $username = empty($account) ? $grant->uid : format_username($account);
  $rolename = empty($role) ? $grant->rid : $role->name;

  return t("@user's access as @role", array('@user' => $username, '@role' => $rolename));
}

/**
 * Returns the list of realms on an access grant.
 *
 * @param $grant
 *   An access grant object.
 *
 * @return
 *   A list of assigned realms, where the keys are the values of the grant's
 *   access realm field, and the values are the realm labels.
 */
function access_grant_realms($grant) {
  $field_name = access_scheme_fieldname($grant->scheme);
  $assigned = isset($grant->$field_name) ? $grant->$field_name : array('und' => array());

  // Get the list of allowed realms for the scheme.
  $allowed = access_scheme_realms($grant->scheme);

  $realms = array();
  foreach ($assigned['und'] as $data) {
    $key = $data['value'];
    if (isset($allowed[$key])) {
      $realms[$key] = field_filter_xss($allowed[$key]);
    }
  }
  return $realms;
}

/**
 * Loads an access grant from the database.
 *
 * @param $gid
 *   The grant ID.
 * @param $reset
 *   (optional) Whether to reset the internal cache.  Defaults to FALSE.
 *
 * @return
 *   An access grant object, or FALSE if the grant is not found.
 */
function access_grant_load($gid, $reset = FALSE) {
  $grants = access_grant_load_multiple(array($gid), $reset);
  return reset($grants);
}

/**
 * Loads access grants from the database based on a set of conditions.
 *
 * @param $conditions
 *   An array of search conditions. Valid conditions are:
 *   - 'scheme': a scheme name.
 *   - 'uid': a user ID.
 *   - 'rid': a role ID.
 *   - 'realms': an array of realm values.  Only used if 'scheme' is provided.
 * @param $reset
 *   (optional) Whether to reset the internal cache.  Defaults to FALSE.
 *
 * @return
 *   An array of access grant objects matching the given parameters.
 */
function access_grant_load_by_condition($conditions = array(), $reset = FALSE) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'access_grant');

  if (isset($conditions['scheme'])) {
    $query->entityCondition('bundle', $conditions['scheme']);
    if (isset($conditions['realms'])) {
      $field_name = access_scheme_fieldname($conditions['scheme']);
      $query->fieldCondition($field_name, 'value', $conditions['realms']);
    }
  }
  if (isset($conditions['uid'])) {
    $query->propertyCondition('uid', $conditions['uid']);
  }
  if (isset($conditions['rid'])) {
    $query->propertyCondition('rid', $conditions['rid']);
  }

  $result = $query->execute();
  if (empty($result)) {
    return array();
  }
  $gids = array_keys($result['access_grant']);
  return access_grant_load_multiple($gids, $reset);
}

/**
 * Loads access grants from the database.
 *
 * Rather than accepting the deprecated $conditions parameter, as entity_load()
 * does, this function instead enforces the new preferred approach of using
 * EntityFieldQuery to get a list of grant IDs before calling this function.
 *
 * @param $gids
 *   An array of grant IDs, or FALSE to load all grants.
 * @param $reset
 *   Whether to reset the internal cache.
 *
 * @return
 *   An array of access grant objects indexed by their IDs. When no results
 *   are found, an empty array is returned.
 *
 * @see entity_load()
 * @see EntityFieldQuery
 */
function access_grant_load_multiple($gids = FALSE, $reset = FALSE) {
  return entity_load('access_grant', $gids, array(), $reset);
}

/**
 * Saves an access grant to the database.
 *
 * @param $grant
 *   An access grant object.
 *
 * @return
 *   Status constant indicating whether the grant was inserted (SAVED_NEW) or
 *   updated (SAVED_UPDATED). When inserting a new grant, $grant->gid will
 *   contain the ID of the newly created grant.
 *
 * @see AccessGrantEntityController::save()
 */
function access_grant_save($grant) {
  return entity_get_controller('access_grant')->save($grant);
}

/**
 * Deletes an access grant from the database.
 *
 * @param $gid
 *   The grant ID.
 *
 * @return
 *   Status constant indicating deletion.
 *
 * @see AccessGrantEntityController::delete()
 */
function access_grant_delete($gid) {
  return entity_get_controller('access_grant')->delete($gid);
}

/**
 * Menu title callback for an access grant.
 */
function access_grant_page_title($grant) {
  return access_grant_label($grant);
}

/**
 * Menu title callback for adding a grant within a scheme.
 */
function access_grant_add_page_title($scheme) {
  return t('Grant access to @scheme', array('@scheme' => $scheme->name));
}

/**
 * Menu page callback; view a single access grant.
 */
function access_grant_page_view($grant) {
  $grants = access_grant_view_multiple(array($grant->gid => $grant), 'full');
  return $grants;
}

/**
 * Constructs an array for drupal_render() from an array of access grants.
 *
 * @param $grants
 *   An array of grants objects, as returned by access_grant_load_multiple().
 * @param $view_mode
 *   View mode, e.g. 'full'.
 * @param $weight
 *   An integer representing the weight of the first grant in the list.
 *
 * @return
 *   An array in the format expected by drupal_render().
 */
function access_grant_view_multiple($grants, $view_mode = 'full', $weight = 0) {
  field_attach_prepare_view('access_grant', $grants, $view_mode);
  entity_prepare_view('access_grant', $grants);
  $build = array();
  foreach ($grants as $grant) {
    $build['grants'][$grant->gid] = access_grant_view($grant, $view_mode);
    $build['grants'][$grant->gid]['#weight'] = $weight;
    $weight++;
  }
  $build['grants']['#sorted'] = TRUE;
  return $build;
}

/**
 * Generates an array for rendering the given access grant.
 *
 * @param $grant
 *   An access grant object.
 * @param $view_mode
 *   View mode, e.g. 'full'.
 *
 * @return
 *   An array in the format expected by drupal_render().
 */
function access_grant_view($grant, $view_mode = 'full') {
  // Retrieve all fields and attach to $grant->content.
  access_grant_build_content($grant, $view_mode);

  $build = $grant->content;
  // We don't need it twice.
  unset($grant->content);

  $build += array(
    '#theme' => 'access_grant',
    '#access_grant' => $grant,
    '#view_mode' => $view_mode,
  );

  $type = 'access_grant';
  drupal_alter(array('access_grant_view', 'entity_view'), $build, $type);

  return $build;
}

/**
 * Builds a structured array representing the access grant in $grant->content.
 *
 * @param $grant
 *   An access grant object.
 * @param $view_mode
 *   View mode, e.g. 'full'.
 */
function access_grant_build_content($grant, $view_mode = 'full') {
  $grant->content = array();

  // Build fields content.
  // An internal flag prevents this from happening twice, such as when called
  // through access_grant_view_multiple().
  field_attach_prepare_view('access_grant', array($grant->gid => $grant), $view_mode);
  entity_prepare_view('access_grant', array($grant->gid => $grant));
  $grant->content += field_attach_view('access_grant', $grant, $view_mode);

  module_invoke_all('access_grant_view', $grant, $view_mode);
  module_invoke_all('entity_view', $grant, 'access_grant', $view_mode);
}

/**
 * AJAX callback for the access grant form.
 */
function access_grant_form_ajax($form, $form_state) {
  return $form['role'];
}

/**
 * Implements hook_access_grant_view().
 */
function access_access_grant_view($grant) {
  $account = user_load($grant->uid);
  $grant->content['user'] = array(
    '#type' => 'item',
    '#title' => t('User:'),
    '#markup' => theme('username', array('account' => $account)),
    '#weight' => -5,
  );

  $role = user_role_load($grant->rid);
  $grant->content['role'] = array(
    '#type' => 'item',
    '#title' => t('Role:'),
    '#markup' => check_plain($role->name),
    '#weight' => -4,
  );
}

/**
 * Sets the default values for an access scheme.
 *
 * @param $info
 *   An object or array containing values to override the defaults.
 *
 * @return
 *   An access scheme object.
 */
function access_scheme_set_defaults($info = array()) {
  $info = (array) $info;
  $new_scheme = $info + array(
    'scheme' => '',
    'name' => '',
    'realm_type' => '',
    'description' => '',
  );
  $new_scheme = (object) $new_scheme;
  return $new_scheme;
}

/**
 * Returns a list of all defined access scheme names.
 *
 * @return
 *   An array of scheme names, keyed by machine name.
 */
function access_scheme_get_names() {
  return db_query('SELECT scheme, name FROM {access_scheme} ORDER BY scheme')->fetchAllKeyed();
}

/**
 * Returns an array of access schemes.
 *
 * @param $schemes
 *   (optional) An access scheme machine name string, or an array of such names.
 *
 * @return
 *   An array of access scheme objects matching the given machine name(s), keyed
 *   by machine name.  If $schemes is not given, returns all defined schemes.
 */
function access_scheme_get_schemes($schemes = NULL) {
  $query = db_select('access_scheme', 'a')
    ->fields('a')
    ->orderBy('a.scheme');

  if (isset($schemes)) {
    if (is_array($schemes)) {
      $query->condition('a.scheme', $schemes, 'IN');
    }
    else {
      $query->condition('a.scheme', $schemes);
    }
  }

  $result = $query->execute()->fetchAllAssoc('scheme');
  foreach ($result as $record) {
    access_handler_attach_handlers($record);
  }
  return $result;
}

/**
 * Returns the scheme for a given access grant.
 *
 * @param $grant
 *   An access grant object, or an access scheme machine name string.
 *
 * @return
 *   A single access scheme object, or FALSE if not found.
 */
function access_scheme_get_scheme($grant) {
  $scheme = is_object($grant) ? $grant->scheme : $grant;
  $result = access_scheme_get_schemes($scheme);
  return reset($result);
}

/**
 * Loads an access scheme by its URL-friendly machine name.
 *
 * @param $scheme
 *   The machine-readable name of a scheme, where '_' is replaced with '-'.
 *
 * @return
 *   An access scheme object, or FALSE if $scheme does not exist.
 */
function access_scheme_load($scheme) {
  return access_scheme_get_scheme(strtr($scheme, array('-' => '_')));
}

/**
 * Saves an access scheme to the database.
 *
 * @param $scheme
 *   The access scheme to save, as an object.
 *
 * @return
 *   Status flag indicating the outcome of the database operation.
 */
function access_scheme_save($scheme) {
  // Sanitize the values.
  $scheme = access_scheme_set_defaults($scheme);
  $scheme->scheme = (string) $scheme->scheme;
  $fields = array();
  foreach (array('name', 'realm_type', 'description') as $key) {
    $scheme->$key = (string) $scheme->$key;
    $fields[$key] = $scheme->$key;
  }

  // Look for an existing scheme.
  if (!isset($scheme->original)) {
    $scheme->original = access_scheme_get_scheme($scheme->scheme);
  }

  // The machine name and realm type are not editable after creation.
  if (!empty($scheme->original)) {
    $scheme->scheme = $scheme->original->scheme;
    $scheme->realm_type = $fields['realm_type'] = $scheme->original->realm_type;
  }

  // Save the scheme.
  $status = db_merge('access_scheme')
    ->key(array('scheme' => $scheme->scheme))
    ->fields($fields)
    ->execute();
  switch ($status) {
    case SAVED_NEW:
      field_attach_create_bundle('access_grant', $scheme->scheme);
      module_invoke_all('access_scheme_insert', $scheme);
      break;

    case SAVED_UPDATED:
      module_invoke_all('access_scheme_update', $scheme);
      break;
  }
  return $status;
}

/**
 * Deletes an access scheme from the database.
 *
 * @param $scheme
 *   The machine-readable name of the access scheme to be deleted.
 */
function access_scheme_delete($scheme) {
  $info = access_scheme_get_scheme($scheme);

  // Detach any access handlers for this scheme.
  db_delete('access_handler')
    ->condition('scheme', $scheme)
    ->execute();

  // Delete the access scheme definition.
  db_delete('access_scheme')
    ->condition('scheme', $scheme)
    ->execute();

  // Delete the scheme's role configuration.
  variable_del('access_scheme_roles_' . $scheme);

  // Notify the Field API and other interested modules of the deletion.
  field_attach_delete_bundle('access_grant', $scheme);
  module_invoke_all('access_scheme_delete', $info);
}

/**
 * Implements hook_access_scheme_insert().
 */
function access_access_scheme_insert($scheme) {
  // Create the realm field for the scheme.
  if ($info = access_realm_info($scheme->realm_type)) {
    $field_name = access_scheme_fieldname($scheme);

    // Make sure the field type is supported.
    $field_types = access_field_info();
    if (!isset($field_types[$info['field_type']])) {
      return;
    }

    // Create the field.
    $field = field_info_field($field_name);
    if (empty($field)) {
      $field = array(
        'field_name' => $field_name,
        'type' => $info['field_type'],
        'entity_types' => array('access_grant'),
        'cardinality' => -1,
        'locked' => TRUE,
        'settings' => array(
          'arguments' => isset($info['arguments']) ? $info['arguments'] : array(),
        ),
      );
      // If the realm field is configurable, merge in any available field
      // settings attached to the scheme.
      if (!empty($field['settings']['arguments']) && isset($scheme->realm_settings)) {
        $field['settings']['arguments'] = array_merge($field['settings']['arguments'], $scheme->realm_settings);
      }
      $field = field_create_field($field);
    }

    // Create the instance.
    $instance = field_info_instance('access_grant', $field_name, $scheme->scheme);
    if (empty($instance)) {
      $instance = array(
        'field_name' => $field_name,
        'entity_type' => 'access_grant',
        'bundle' => $scheme->scheme,
        'label' => check_plain($scheme->name),
        'description' => filter_xss($scheme->description),
        'required' => TRUE,
      );
      $instance = field_create_instance($instance);
    }
  }
}

/**
 * Implements hook_access_scheme_update().
 */
function access_access_scheme_update($scheme) {
  // If the realm field is configurable, merge in any available field settings
  // attached to the scheme.
  $field = field_info_field(access_scheme_fieldname($scheme));
  if (!empty($field['settings']['arguments']) && isset($scheme->realm_settings)) {
    $field['settings']['arguments'] = array_merge($field['settings']['arguments'], $scheme->realm_settings);
    field_update_field($field);
  }
}

/**
 * Returns the expected name of the access field for given scheme.
 *
 * @param $scheme
 *   An access scheme object, or the machine-readable name of an access scheme.
 *
 * @return
 *   The expected name of the access field.  Note that neither the scheme nor
 *   the field need to exist for this function to succeed.
 */
function access_scheme_fieldname($scheme) {
  // Schemes and realm fields have a one-to-one relationship, so naming the
  // field after the scheme should guarantee uniqueness.
  return is_object($scheme) ? 'ack_' . $scheme->scheme : 'ack_' . $scheme;
}

/**
 * Menu title callback for an access scheme.
 */
function access_scheme_page_title($scheme) {
  return check_plain($scheme->name);
}

/**
 * Returns a list of all realms in an access scheme.
 *
 * @param $scheme
 *   An access scheme object, or the machine-readable name of an access scheme.
 *
 * @return
 *   An array of realms.  The keys are the raw stored values (number or text)
 *   that identify the realm and the values are the realm display labels.
 */
function access_scheme_realms($scheme) {
  $field = field_info_field(access_scheme_fieldname($scheme));
  return empty($field) ? array() : access_field_allowed_values($field);
}

/**
 * Returns a list of user roles available for use within an access scheme.
 *
 * @param $scheme
 *   (optional) An access scheme object, or the machine-readable name of an
 *   access scheme. If excluded, roles for all schemes will be returned.
 *
 * @return
 *   An associative array of roles that can be used in the scheme, with the role
 *   id as the key and the role name as the value. If $scheme was omitted, this
 *   will be a nested array, indexed by scheme machine name, containing the role
 *   lists for all defined access schemes.
 */
function access_scheme_roles($scheme = NULL) {
  if (isset($scheme)) {
    $schemes = is_object($scheme) ? array($scheme->scheme) : array($scheme);
  }
  else {
    $schemes = array_keys(access_scheme_get_names());
  }

  // Get all user roles, excluding "anonymous users" and "authenticated users."
  $roles = user_roles(TRUE);
  unset($roles[DRUPAL_AUTHENTICATED_RID]);

  // Filter each scheme's roles list to only include valid roles.  We do this
  // (rather than trusting the scheme variable) to ensure that misconfiguration
  // of the variable doesn't result in showing roles that do not exist.
  $list = array();
  foreach ($schemes as $machine_name) {
    $scheme_roles = variable_get('access_scheme_roles_' . $machine_name, array());
    $list[$machine_name] = array_intersect_assoc($roles, $scheme_roles);
  }

  if (isset($scheme)) {
    return reset($list);
  }
  return $list;
}

/**
 * Returns access realm info.
 *
 * @param $realm_type
 *   (optional) A realm type string.
 *
 * @return
 *   The information array for the requested $realm_type, or FALSE if not found.
 *   If $realm_type is omitted, returns information for all available types.
 *
 * @see hook_access_realm_info()
 */
function access_realm_info($realm_type = NULL) {
  $types = array();
  foreach (module_implements('access_realm_info') as $module) {
    $info = module_invoke($module, 'access_realm_info');
    foreach (array_keys($info) as $type) {
      $info[$type]['module'] = $module;
      $info[$type]['realm_type'] = $type;
    }
    $types += $info;
  }

  if (isset($realm_type)) {
    return isset($types[$realm_type]) ? $types[$realm_type] : FALSE;
  }
  return $types;
}

/**
 * Returns the access realm info for a given access field.
 *
 * @param $field
 *   A field definition, as returned by field_info_field().
 *
 * @return
 *   The information array for the field's realm type, or FALSE if not found.
 */
function access_realm_info_by_field($field) {
  // Make sure the field is an access field.
  // Only supports a one-to-one relationship between schemes and access fields.
  $info = access_field_info();
  if (isset($info[$field['type']]) && !empty($field['bundles']['access_grant']) && $scheme = access_scheme_get_scheme(reset($field['bundles']['access_grant']))) {
    return access_realm_info($scheme->realm_type);
  }
  return FALSE;
}

/**
 * Returns an options list of all available realm types.
 *
 * @return
 *   An array where the keys are realm types and values are realm type labels.
 */
function access_realm_options() {
  $options = array();
  $realms = access_realm_info();
  foreach ($realms as $realm_type => $info) {
    $options[$realm_type] = $info['label'];
  }
  asort($options);
  return $options;
}

/**
 * Implements hook_field_info().
 *
 * @see list_field_info()
 */
function access_field_info() {
  $settings = array(
    'arguments' => array(),
  );

  // These are similar to the field types defined in list.module, but with an
  // 'arguments' setting to be used by ACK realm plugins and 'no_ui' set to
  // prevent access fields from being reused in other scheme bundles.
  return array(
    'access_integer' => array(
      'label' => t('Access control kit realm (integer)'),
      'description' => t('Controls access via an integer value.'),
      'settings' => $settings,
      'default_widget' => 'options_buttons',
      'default_formatter' => 'access_default',
      'no_ui' => TRUE,
    ),
    'access_float' => array(
      'label' => t('Access control kit realm (float)'),
      'description' => t('Controls access via a float value.'),
      'settings' => $settings,
      'default_widget' => 'options_buttons',
      'default_formatter' => 'access_default',
      'no_ui' => TRUE,
    ),
    'access_text' => array(
      'label' => t('Access control kit realm (text)'),
      'description' => t('Controls access via a text value.'),
      'settings' => $settings,
      'default_widget' => 'options_buttons',
      'default_formatter' => 'access_default',
      'no_ui' => TRUE,
    ),
    'access_boolean' => array(
      'label' => t('Access control kit realm (boolean)'),
      'description' => t('Controls access via a boolean value.'),
      'settings' => $settings,
      'default_widget' => 'options_buttons',
      'default_formatter' => 'access_default',
      'no_ui' => TRUE,
    ),
  );
}

/**
 * Implements hook_field_validate().
 *
 * Possible error codes:
 * - 'access_illegal_value': The value is not in the list of allowed values.
 *
 * @see list_field_validate()
 */
function access_field_validate($entity_type, $entity, $field, $instance, $langcode, $items, &$errors) {
  $allowed_values = access_field_allowed_values($field);
  foreach ($items as $delta => $item) {
    if (!empty($item['value'])) {
      if (empty($allowed_values) || !isset($allowed_values[$item['value']])) {
        $errors[$field['field_name']][$langcode][$delta][] = array(
          'error' => 'access_illegal_value',
          'message' => t('%name: illegal value.', array('%name' => $instance['label'])),
        );
      }
    }
  }
}

/**
 * Implements hook_field_is_empty().
 *
 * @see list_field_is_empty()
 */
function access_field_is_empty($item, $field) {
  if (empty($item['value']) && (string) $item['value'] !== '0') {
    return TRUE;
  }
  return FALSE;
}

/**
 * Returns the set of allowed values (realms) for an access field.
 *
 * @param $field
 *   The field definition.
 *
 * @return
 *   The array of allowed values. Keys of the array are the raw stored values
 *   (number or text), values of the array are the display labels.
 *
 * @see hook_access_realms()
 */
function access_field_allowed_values($field) {
  $info = access_realm_info_by_field($field);
  if ($info) {
    return module_invoke($info['module'], 'access_realms', $info['realm_type'], $field['settings']['arguments']);
  }
}

/**
 * Implements hook_field_widget_info_alter().
 *
 * @see list_field_widget_info_alter()
 */
function access_field_widget_info_alter(&$info) {
  $widgets = array(
    'options_select' => array('access_integer', 'access_float', 'access_text'),
    'options_buttons' => array('access_integer', 'access_float', 'access_text', 'access_boolean'),
    'options_onoff' => array('access_boolean'),
  );

  foreach ($widgets as $widget => $field_types) {
    $info[$widget]['field types'] = array_merge($info[$widget]['field types'], $field_types);
  }
}

/**
 * Implements hook_options_list().
 */
function access_options_list($field, $instance, $entity_type, $entity) {
  return access_field_allowed_values($field);
}

/**
 * Implements hook_field_settings_form().
 *
 * @see hook_access_realm_settings()
 */
function access_field_settings_form($field, $instance, $has_data) {
  $info = access_realm_info_by_field($field);
  $form['arguments'] = module_invoke($info['module'], 'access_realm_settings', $info['realm_type'], $has_data, $field['settings']['arguments']);
  $form['arguments']['#tree'] = TRUE;
  return $form;
}

/**
 * Implements hook_field_formatter_info().
 *
 * @see list_field_formatter_info()
 */
function access_field_formatter_info() {
  return array(
    'access_default' => array(
      'label' => t('Default'),
      'field types' => array('access_integer', 'access_float', 'access_text', 'access_boolean'),
    ),
  );
}

/**
 * Implements hook_field_formatter_view().
 *
 * @see list_field_formatter_view()
 */
function access_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();

  switch ($display['type']) {
    case 'access_default':
      $allowed_values = access_field_allowed_values($field);
      foreach ($items as $delta => $item) {
        if (isset($allowed_values[$item['value']])) {
          $output = field_filter_xss($allowed_values[$item['value']]);
        }
        else {
          // If no match was found in allowed values, fall back to the key.
          $output = field_filter_xss($item['value']);
        }
        $element[$delta] = array('#markup' => $output);
      }
      break;
  }

  return $element;
}

/**
 * Implements hook_field_extra_fields().
 */
function access_field_extra_fields() {
  $extra = array();
  $fields = array(
    'user' => array(
      'label' => t('User'),
      'description' => t('Access control kit user reference'),
      'weight'=> -5,
    ),
    'role' => array(
      'label' => t('Role'),
      'description' => t('Access control kit role reference'),
      'weight' => -4,
    ),
  );

  foreach (access_scheme_get_names() as $scheme => $name) {
    $extra['access_grant'][$scheme] = array(
      'form' => $fields,
      'display' => $fields,
    );
  }

  return $extra;
}

/**
 * Attaches configured access handlers to a scheme.
 *
 * @param $scheme
 *   An access scheme object. Any handlers attached to the scheme will be added
 *   in $scheme->handlers as an array of AccessControlKit objects, indexed by
 *   object type (e.g. the node handler will be in $scheme->handlers['node']).
 */
function access_handler_attach_handlers($scheme) {
  // Remove any previously built handlers, if any.
  $scheme->handlers = array();

  // Fetch handler configs from the database.
  $result = db_query('SELECT * FROM {access_handler} WHERE scheme = :scheme', array(':scheme' => $scheme->scheme));
  foreach ($result as $row) {
    // Initialize the handler using the class and settings from the database.
    $class = $row->handler;
    $settings = unserialize($row->settings);
    $scheme->handlers[$row->object_type] = new $class($scheme->scheme, $row->object_type, $settings);
  }
}

/**
 * Saves an access handler attachment to the database.
 *
 * @param $scheme
 *   The name of the access scheme to which to attach the handler.
 * @param $object_type
 *   The type of Drupal object that the handler will manage (e.g. node).
 * @param $handler
 *   The name of the access handler class to attach.
 * @param $module
 *   The module that provides the handler.
 * @param $settings
 *   (optional) An array of settings to control the handler's behavior.
 *
 * @return
 *   Status flag indicating the outcome of the database operation.
 */
function access_handler_save($scheme, $object_type, $handler, $module, $settings = array()) {
  // Sanitize the inputs.
  $key = array(
    'scheme' => (string) $scheme,
    'object_type' => (string) $object_type,
  );
  $fields = array(
    'handler' => (string) $handler,
    'module' => (string) $module,
    'settings' => is_array($settings) ? $settings : array($settings),
  );
  $fields['settings'] = serialize($fields['settings']);

  // Add/update the attachment.
  $status = db_merge('access_handler')
    ->key($key)
    ->fields($fields)
    ->execute();
  return $status;
}

/**
 * Deletes an access handler attachment from the database.
 *
 * @param $scheme
 *   The name of the access scheme to which the handler is attached.
 * @param $object_type
 *   The type of Drupal object that the handler manages (e.g. node).
 */
function access_handler_delete($scheme, $object_type) {
  db_delete('access_handler')
    ->condition('scheme', $scheme)
    ->condition('object_type', $object_type)
    ->execute();
}

/**
 * AJAX callback for access handler settings forms.
 *
 * @see access_scheme_form()
 */
function access_handler_form_ajax($form, $form_state) {
  return $form['handlers']['handlers'];
}

/**
 * Returns information on all available object access handlers.
 *
 * @return
 *   An array indexed by handler name where each value is an associative array
 *   with the following keys:
 *   - label: The human-readable name of this handler.
 *   - realm types: An array listing the realm types that this handler supports,
 *     as defined in hook_access_realm_info().
 *   - object types: An array listing the object types that this handler
 *     supports, as defined in hook_access_info(). A value of 'fieldable entity'
 *     indicates that the handler supports all object types that are fieldable
 *     entities, as defined by hook_entity_info().
 *   - class: The name of the handler class.
 *   - module: The module that provides the handler class.
 *
 * @see hook_access_handler_info()
 * @see hook_access_handler_info_alter()
 */
function access_handler_info() {
  $info = &drupal_static(__FUNCTION__, array());
  if (empty($info)) {
    if ($cache = cache_get('access_handler_info')) {
      $info = $cache->data;
    }
    else {
      foreach (module_implements('access_handler_info') as $module) {
        if ($module_info = module_invoke($module, 'access_handler_info')) {
          foreach ($module_info as $handler_name => $handler_info) {
            // Merge in default values.
            $module_info[$handler_name] += array(
              'label' => '',
              'realm types' => array(),
              'object types' => array(),
            );
            // Set inferred values.
            $module_info[$handler_name]['class'] = $handler_name;
            $module_info[$handler_name]['module'] = $module;
          }
          $info += $module_info;
        }
      }
      drupal_alter('access_handler_info', $info);
      cache_set('access_handler_info', $info);
    }
  }
  return $info;
}

/**
 * Returns information on all available access-controlled object types.
 *
 * @return
 *   An array indexed by object type (e.g., "node", "menu_link") where each
 *   value is an associative array with the following keys:
 *   - label: The human-readable name of this object type (e.g., "Content",
 *     "Menu link").
 *   - type: The machine name of this object type (e.g., "node", "menu_link").
 *   - module: The module that provides ACK-compatibility for the object type.
 *   - fieldable: Boolean indicating whether or not this object type is a
 *     fieldable entity, as defined by hook_entity_info().
 *   - handlers: An array listing the access handlers that support this object
 *     type, as defined in hook_access_handler_info().
 *
 * @see hook_access_info()
 * @see hook_access_info_alter()
 */
function access_info() {
  $info = &drupal_static(__FUNCTION__, array());
  if (empty($info)) {
    if ($cache = cache_get('access_info')) {
      $info = $cache->data;
    }
    else {
      $handlers = access_handler_info();
      foreach (module_implements('access_info') as $module) {
        if ($module_info = module_invoke($module, 'access_info')) {
          foreach ($module_info as $object_type => $object_info) {
            $info[$object_type]['label'] = $object_info['label'];
            $info[$object_type]['type'] = $object_type;
            $info[$object_type]['module'] = $module;

            // Check whether the object is a fieldable entity.
            $entity_info = entity_get_info($object_type);
            $info[$object_type]['fieldable'] = empty($entity_info) ? FALSE : $entity_info['fieldable'];

            // Find handlers that support this object type.
            $info[$object_type]['handlers'] = array();
            foreach ($handlers as $handler_name => $handler_info) {
              // If the object is a fieldable entity and the handler supports all
              // fieldable entities, or if the handler explicitly supports this
              // object type, add the handler to the list.
              if (($info[$object_type]['fieldable'] && in_array('fieldable entity', $handler_info['object types'])) || in_array($object_type, $handler_info['object types'])) {
                $info[$object_type]['handlers'][] = $handler_name;
              }
            }
          }
        }
      }
      drupal_alter('access_info', $info);
      cache_set('access_info', $info);
    }
  }
  return $info;
}

/**
 * Returns a list of realms that apply to an object per scheme.
 *
 * @param $object_type
 *   The type of access controlled object, such as 'node'.
 * @param $object
 *   The object for which to return realm memberships.
 * @param $schemes
 *   (optional) An array of access scheme objects. If given, returns only realm
 *   memberships for these schemes. Otherwise, returns realms for all schemes.
 *
 * @return
 *   An array indexed by scheme machine name where each value is an array of
 *   realms of which the $object is a member according to that scheme. If the
 *   $object is not a member of any realms for a scheme, that scheme's value
 *   will be array().
 */
function access_object_realms($object_type, $object, $schemes = NULL) {
  if (!isset($schemes)) {
    $schemes = access_scheme_get_schemes();
  }
  $realms = array();
  foreach ($schemes as $scheme) {
    $realms[$scheme->scheme] = isset($scheme->handlers[$object_type]) ? $scheme->handlers[$object_type]->getRealms($object) : array();
  }
  return $realms;
}

/**
 * Returns a list of a user's ACK roles with scheme and realm assignments.
 *
 * @param $account
 *   (optional) The account to check. Defaults to the currently logged in user.
 *
 * @return
 *   A nested array indexed first by role ID, then by scheme machine name, where
 *   the values are an array containing the user's assigned realms for that role
 *   in that scheme. Note that the list of roles is limited to those returned by
 *   access_scheme_roles() for each scheme; non-ACK roles are excluded.
 *
 * @see access_scheme_roles()
 */
function access_user_roles($account = NULL) {
  global $user;
  if (!isset($account)) {
    $account = $user;
  }

  // Cache the user's role list using the advanced drupal_static() pattern for
  // best performance on repeated access checks.
  static $drupal_static_fast;
  if (!isset($drupal_static_fast)) {
    $drupal_static_fast['user_roles'] = &drupal_static(__FUNCTION__);
  }
  $user_roles = &$drupal_static_fast['user_roles'];

  // On cache miss, load all grants for the user and sort by role and scheme.
  if (!isset($user_roles[$account->uid])) {
    $grants = access_grant_load_by_condition(array('uid' => $account->uid));
    $allowed_roles = access_scheme_roles();
    $roles = array();
    foreach ($grants as $grant) {
      // Only include roles that are in the current list of ACK-enabled roles
      // (in case the scheme settings have changed), and that are currently
      // associated with the user (in case another module revoked a role without
      // ACK being notified to clean up grants).
      if (isset($allowed_roles[$grant->scheme][$grant->rid]) && isset($account->roles[$grant->rid])) {
        $roles[$grant->rid][$grant->scheme] = access_grant_realms($grant);
      }
    }
    $user_roles[$account->uid] = $roles;
  }

  return $user_roles[$account->uid];
}

/**
 * Determines whether a user has a permission on an object via an access grant.
 *
 * @param $string
 *   The permission, such as "edit any page".
 * @param $object_type
 *   The type of access controlled object, such as "node".
 * @param $object
 *   The object that the user is trying to access. May be an object or an array,
 *   depending on the $object_type.
 * @param $scheme
 *   (optional) The machine name of the access scheme in which to check access.
 *   If omitted, access is checked in all available access schemes.
 * @param $account
 *   (optional) The account to check. Defaults to the currently logged in user.
 *
 * @return
 *   Boolean TRUE if the user has the requested permission on the object via an
 *   access grant in the $scheme, or in any scheme if $scheme was omitted.
 */
function access_user_object_access($string, $object_type, $object, $scheme = NULL, $account = NULL) {
  global $user;
  if (!isset($account)) {
    $account = $user;
  }

  // Sanity check to make sure that the user has the permission at all.
  if (!user_access($string, $account)) {
    return FALSE;
  }

  // Get the object's realm memberships.
  if (isset($scheme)) {
    $schemes = array($scheme => access_scheme_get_scheme($scheme));
  }
  else {
    $schemes = access_scheme_get_schemes();
  }
  $object_realms = access_object_realms($object_type, $object, $schemes);

  // Check the user's access in each scheme.
  foreach ($schemes as $scheme_info) {
    $user_realms = access_user_permission_realms($string, $scheme_info->scheme, $account);
    foreach ($object_realms[$scheme_info->scheme] as $realm) {
      if (isset($user_realms[$realm])) {
        // If we get a match, there's no need to keep checking other schemes.
        return TRUE;
      }
    }
  }
  return FALSE;
}

/**
 * Finds the realms where a user has a given permission via an access grant.
 *
 * @param $string
 *   The permission, such as "edit any page".
 * @param $scheme
 *   (optional) The machine name of the access scheme in which to check access.
 *   If omitted, access is checked in all available access schemes.
 * @param $account
 *   (optional) The account to check. Defaults to the currently logged in user.
 *
 * @return
 *   An array whose keys are the realm values for which the user has been
 *   granted the permission, and whose values are the corresponding realm
 *   labels.  An empty array() indicates that the user does not have the
 *   permission in any realm in the scheme.  If the $scheme paramater was
 *   omitted, this will be a nested array indexed by scheme machine name.
 */
function access_user_permission_realms($string, $scheme = NULL, $account = NULL) {
  global $user;
  if (!isset($account)) {
    $account = $user;
  }

  if (isset($scheme)) {
    $schemes = array($scheme);
  }
  else {
    $schemes = array_keys(access_scheme_get_names());
  }

  // Get the user's realm role assignments via access grants.
  $roles = access_user_roles($account);
  // Filter out any roles that do not include the permission we're looking for.
  foreach (user_role_permissions($roles) as $rid => $permissions) {
    if (empty($permissions[$string])) {
      unset($roles[$rid]);
    }
  }

  // Find the accessible realms for each scheme.
  $realms = array();
  foreach ($schemes as $machine_name) {
    $scheme_realms = array();
    foreach ($roles as $access) {
      if (!empty($access[$machine_name])) {
        $scheme_realms += $access[$machine_name];
      }
    }
    $realms[$machine_name] = $scheme_realms;
  }
  return isset($scheme) ? reset($realms) : $realms;
}

/**
 * Implements hook_theme().
 */
function access_theme() {
  return array(
    'access_schemes_overview' => array(
      'variables' => array('scheme' => NULL),
      'file' => 'access_schemes.admin.inc',
    ),
    'access_grant' => array(
      'render element' => 'elements',
      'template' => 'access-grant',
      'file' => 'access_grants.admin.inc',
    ),
  );
}

/**
 * Implements hook_permission().
 */
function access_permission() {
  $perms['administer access schemes'] = array(
    'title' => t('Administer access schemes'),
    'description' => t('Define the means by which objects in the site are divided into access realms.'),
    'restrict access' => TRUE,
  );
  $perms['administer access grants'] = array(
    'title' => t('Administer access grants'),
    'description' => t('Assign roles to users within access realms.'),
    'restrict access' => TRUE,
  );
  return $perms;
}

/**
 * Implements hook_menu().
 */
function access_menu() {
  // Manage access grants.
  $items['admin/access'] = array(
    'title' => 'Access',
    'description' => 'Manage access grants.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('access_overview_grants'),
    'access arguments' => array('administer access grants'),
    // -2 places it between "People" and "Modules" on the default admin menu.
    'weight' => -2,
    'file' => 'access_grants.admin.inc',
  );
  $items['admin/access/list'] = array(
    'title' => 'List',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $items['admin/access/add'] = array(
    'title' => 'Add access grant',
    'page callback' => 'access_grant_add_list',
    'access arguments' => array('administer access grants'),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'access_grants.admin.inc',
  );
  $items['admin/access/add/%access_scheme'] = array(
    'title' => 'Add access grant for scheme',
    'title callback' => 'access_grant_add_page_title',
    'title arguments' => array(3),
    'page callback' => 'access_grant_add',
    'page arguments' => array(3),
    'access arguments' => array('administer access grants'),
    'file' => 'access_grants.admin.inc',
  );
  $items['admin/access/grant/%access_grant'] = array(
    'title callback' => 'access_grant_page_title',
    'title arguments' => array(3),
    'page callback' => 'access_grant_page_view',
    'page arguments' => array(3),
    'access arguments' => array('administer access grants'),
  );
  $items['admin/access/grant/%access_grant/view'] = array(
    'title' => 'View',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $items['admin/access/grant/%access_grant/edit'] = array(
    'title' => 'Edit',
    'page callback' => 'access_grant_edit',
    'page arguments' => array(3),
    'access arguments' => array('administer access grants'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'access_grants.admin.inc',
  );
  $items['admin/access/grant/%access_grant/delete'] = array(
    'title' => 'Delete',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('access_grant_delete_confirm', 3),
    'access arguments' => array('administer access grants'),
    'file' => 'access_grants.admin.inc',
  );

  // Manage access schemes.
  $items['admin/structure/access'] = array(
    'title' => 'Access schemes',
    'description' => 'Define access control schemes.',
    'page callback' => 'access_overview_schemes',
    'access arguments' => array('administer access schemes'),
    'file' => 'access_schemes.admin.inc',
  );
  $items['admin/structure/access/list'] = array(
    'title' => 'List',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $items['admin/structure/access/add'] = array(
    'title' => 'Add access scheme',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('access_scheme_form'),
    'access arguments' => array('administer access schemes'),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'access_schemes.admin.inc',
  );
  $items['admin/structure/access/manage/%access_scheme'] = array(
    'title' => 'Edit access scheme',
    'title callback' => 'access_scheme_page_title',
    'title arguments' => array(4),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('access_scheme_form', 4),
    'access arguments' => array('administer access schemes'),
    'file' => 'access_schemes.admin.inc',
  );
  $items['admin/structure/access/manage/%access_scheme/edit'] = array(
    'title' => 'Edit',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );
  $items['admin/structure/access/manage/%access_scheme/delete'] = array(
    'title' => 'Delete',
    'page arguments' => array('access_scheme_delete_confirm', 4),
    'access arguments' => array('administer access schemes'),
    'file' => 'access_schemes.admin.inc',
  );

  return $items;
}

/**
 * Implements hook_hook_info().
 */
function access_hook_info() {
  $group = array('group' => 'access');
  $list = array('access_grant_presave', 'access_grant_insert', 'access_grant_update', 'access_grant_delete', 'access_grant_view', 'access_scheme_insert', 'access_scheme_update', 'access_scheme_delete', 'access_realm_info', 'access_realms', 'access_realm_settings', 'access_handler_info', 'access_info');
  $hooks = array();
  foreach ($list as $hook) {
    $hooks[$hook] = $group;
  }
  return $hooks;
}
