<?php

/**
 * @file
 * The access control kit module.
 */

/**
 * Implements hook_entity_info().
 */
function access_entity_info() {
  // Access grants.
  $types['access_grant'] = array(
    'label' => t('Access grant'),
    'controller class' => 'AccessGrantEntityController',
    'base table' => 'access_grant',
    'uri callback' => 'access_grant_uri',
    'label callback' => 'access_grant_label',
    'fieldable' => TRUE,
    'entity keys' => array(
      'id' => 'gid',
      'bundle' => 'scheme',
    ),
    'bundle keys' => array(
      'bundle' => 'machine_name',
    ),
    'bundles' => array(),
    'view modes' => array(
      'full' => array(
        'label' => t('Access grant page'),
        'custom settings' => FALSE,
      ),
    ),
  );

  // Bundles are access schemes; the access realm field in the bundle determines
  // which objects are accessible to a user via an access grant.
  foreach (access_scheme_names() as $machine_name => $name) {
    $types['access_grant']['bundles'][$machine_name] = array(
      'label' => $name,
      'admin' => array(
        'path' => 'admin/structure/access/%access_scheme_machine_name',
        'real path' => 'admin/structure/access/' . str_replace('_', '-', $machine_name),
        'bundle argument' => 3,
        'access arguments' => array('administer access schemes'),
      ),
    );
  }

  // Access schemes.
  $types['access_scheme'] = array(
    'label' => t('Access scheme'),
    'controller class' => 'AccessSchemeEntityController',
    'base table' => 'access_scheme',
    'entity keys' => array(
      'id' => 'sid',
      'label' => 'name',
    ),
    'fieldable' => FALSE,
  );

  return $types;
}

/**
 * Entity URI callback for an access grant.
 */
function access_grant_uri($grant) {
  return array('path' => 'admin/access/grant/' . $grant->gid);
}

/**
 * Entity label callback for an access grant.
 */
function access_grant_label($grant) {
  // Load the primary descriptors of the grant.
  $account = user_load($grant->uid);
  $role = user_role_load($grant->rid);

  // Sanitize the descriptors.
  $username = empty($account) ? $grant->uid : format_username($account);
  $rolename = empty($role) ? $grant->rid : $role->name;

  return t("@user's access as @role", array('@user' => $username, '@role' => $rolename));
}

/**
 * Returns the list of realms on an access grant.
 *
 * @param $grant
 *   An access grant.
 *
 * @return
 *   A list of assigned realms, where the keys are the values of the grant's
 *   access realm field, and the values are the realm labels.
 */
function access_grant_realms($grant) {
  $scheme = access_scheme_machine_name_load($grant->scheme);
  $field_name = $scheme->realm_field['field_name'];
  $assigned = isset($grant->$field_name) ? $grant->$field_name : array(LANGUAGE_NONE => array());

  $realms = array();
  foreach ($assigned[LANGUAGE_NONE] as $data) {
    $key = $data['value'];
    // Make sure that the assigned value exists in the scheme's realm list.
    if (isset($scheme->realms[$key])) {
      $realms[$key] = field_filter_xss($scheme->realms[$key]);
    }
  }
  return $realms;
}

/**
 * Loads an access grant by ID.
 *
 * @param $gid
 *   The grant ID.
 * @param $reset
 *   (optional) Whether to reset the internal cache.  Defaults to FALSE.
 *
 * @return
 *   An access grant, or FALSE if the grant is not found.
 */
function access_grant_load($gid, $reset = FALSE) {
  $grants = access_grant_load_multiple(array($gid), $reset);
  return reset($grants);
}

/**
 * Loads all access grants that match a set of conditions.
 *
 * @param $conditions
 *   An array of search conditions. Valid conditions are:
 *   - 'scheme': a scheme machine name.
 *   - 'uid': a user ID.
 *   - 'rid': a role ID.
 *   - 'realms': an array of realm field values. Ignored if 'scheme' is omitted.
 * @param $reset
 *   (optional) Whether to reset the internal cache.  Defaults to FALSE.
 *
 * @return
 *   An array of access grants that match the given conditions.
 */
function access_grant_load_by_condition($conditions = array(), $reset = FALSE) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'access_grant');

  if (isset($conditions['scheme'])) {
    $query->entityCondition('bundle', $conditions['scheme']);
    if (isset($conditions['realms'])) {
      // Make sure that the referenced scheme actually exists.
      if ($scheme = access_scheme_machine_name_load($conditions['scheme'])) {
        $query->fieldCondition($scheme->realm_field['field_name'], 'value', $conditions['realms']);
      }
      // If the scheme doesn't exist, then we can't filter on its realm values,
      // so abort with no matches to the requested conditions.
      else {
        return array();
      }
    }
  }
  if (isset($conditions['uid'])) {
    $query->propertyCondition('uid', $conditions['uid']);
  }
  if (isset($conditions['rid'])) {
    $query->propertyCondition('rid', $conditions['rid']);
  }

  $result = $query->execute();
  if (empty($result)) {
    return array();
  }
  $gids = array_keys($result['access_grant']);
  return access_grant_load_multiple($gids, $reset);
}

/**
 * Loads multiple access grants by ID.
 *
 * @param $gids
 *   An array of grant IDs, or FALSE to load all grants.
 * @param $reset
 *   (optional) Whether to reset the internal cache.  Defaults to FALSE.
 *
 * @return
 *   An array of access grants indexed by their IDs. When no results are found,
 *   returns an empty array.
 *
 * @see entity_load()
 */
function access_grant_load_multiple($gids = FALSE, $reset = FALSE) {
  return entity_load('access_grant', $gids, array(), $reset);
}

/**
 * Saves an access grant.
 *
 * @param $grant
 *   An access grant.
 *
 * @return
 *   Status constant indicating whether the grant was inserted (SAVED_NEW) or
 *   updated (SAVED_UPDATED). When inserting a new grant, $grant->gid will
 *   contain the ID of the newly created grant.
 *
 * @see AccessGrantEntityController::save()
 */
function access_grant_save($grant) {
  return entity_get_controller('access_grant')->save($grant);
}

/**
 * Deletes an access grant.
 *
 * @param $gid
 *   The grant ID.
 *
 * @return
 *   Status constant indicating deletion.
 *
 * @see AccessGrantEntityController::delete()
 */
function access_grant_delete($gid) {
  $controller = entity_get_controller('access_grant');
  $status = $controller->delete($gid);
  $controller->resetCache();
  return $status;
}

/**
 * Constructs an array for drupal_render() from an array of access grants.
 *
 * @param $grants
 *   An array of grants, as returned by access_grant_load_multiple().
 * @param $view_mode
 *   (optional) The view mode. Defaults to 'full'.
 * @param $weight
 *   (optional) An integer representing the weight of the first grant in the
 *   list. Defaults to 0.
 *
 * @return
 *   An array in the format expected by drupal_render().
 *
 * @see drupal_render()
 */
function access_grant_view_multiple($grants, $view_mode = 'full', $weight = 0) {
  field_attach_prepare_view('access_grant', $grants, $view_mode);
  entity_prepare_view('access_grant', $grants);
  $build = array();
  foreach ($grants as $grant) {
    $build['grants'][$grant->gid] = access_grant_view($grant, $view_mode);
    $build['grants'][$grant->gid]['#weight'] = $weight;
    $weight++;
  }
  $build['grants']['#sorted'] = TRUE;
  return $build;
}

/**
 * Generates a renderable array for an access grant.
 *
 * @param $grant
 *   An access grant.
 * @param $view_mode
 *   (optional) The view mode. Defaults to 'full'.
 *
 * @return
 *   An array in the format expected by drupal_render().
 *
 * @see drupal_render()
 */
function access_grant_view($grant, $view_mode = 'full') {
  // Retrieve all fields and attach to $grant->content.
  access_grant_build_content($grant, $view_mode);

  $build = $grant->content;
  // We don't need it twice.
  unset($grant->content);

  $build += array(
    '#theme' => 'access_grant',
    '#access_grant' => $grant,
    '#view_mode' => $view_mode,
  );

  $type = 'access_grant';
  drupal_alter(array('access_grant_view', 'entity_view'), $build, $type);

  return $build;
}

/**
 * Builds a structured array representing the access grant in $grant->content.
 *
 * @param $grant
 *   An access grant.
 * @param $view_mode
 *   (optional) The view mode. Defaults to 'full'.
 */
function access_grant_build_content($grant, $view_mode = 'full') {
  $grant->content = array();

  // Build fields content. An internal flag prevents this from happening twice,
  // such as when called through access_grant_view_multiple().
  field_attach_prepare_view('access_grant', array($grant->gid => $grant), $view_mode);
  entity_prepare_view('access_grant', array($grant->gid => $grant));
  $grant->content += field_attach_view('access_grant', $grant, $view_mode);

  module_invoke_all('access_grant_view', $grant, $view_mode);
  module_invoke_all('entity_view', $grant, 'access_grant', $view_mode);
}

/**
 * Implements hook_access_grant_view().
 */
function access_access_grant_view($grant) {
  $account = user_load($grant->uid);
  $grant->content['user'] = array(
    '#type' => 'item',
    '#title' => t('User:'),
    '#markup' => theme('username', array('account' => $account)),
    '#weight' => -5,
  );

  $role = user_role_load($grant->rid);
  $grant->content['role'] = array(
    '#type' => 'item',
    '#title' => t('Role:'),
    '#markup' => check_plain($role->name),
    '#weight' => -4,
  );
}

/**
 * Menu title callback for adding a grant within a scheme.
 */
function access_grant_add_page_title($scheme) {
  return t('Grant access to @scheme', array('@scheme' => $scheme->name));
}

/**
 * AJAX callback for the access grant form.
 */
function access_grant_form_ajax($form, $form_state) {
  return $form['role'];
}

/**
 * Returns a list of all defined access scheme names.
 *
 * @return
 *   An array of access scheme names, keyed by machine name.
 */
function access_scheme_names() {
  $names = &drupal_static(__FUNCTION__);
  if (!isset($names)) {
    $names = db_query('SELECT machine_name, name FROM {access_scheme} ORDER BY name')->fetchAllKeyed();
  }
  return $names;
}

/**
 * Loads an access scheme by ID.
 *
 * @param $sid
 *   The scheme ID.
 * @param $reset
 *   (optional) Whether to reset the internal cache.  Defaults to FALSE.
 *
 * @return
 *   An access scheme, or FALSE if the scheme is not found.
 */
function access_scheme_load($sid, $reset = FALSE) {
  $schemes = access_scheme_load_multiple(array($sid), $reset);
  return reset($schemes);
}

/**
 * Loads an access scheme by its URL-friendly machine name.
 *
 * @param $machine_name
 *   The machine-readable name of a scheme, where '_' may be replaced with '-'.
 * @param $reset
 *   (optional) Whether to reset the internal cache.  Defaults to FALSE.
 *
 * @return
 *   An access scheme, or FALSE if the scheme is not found.
 */
function access_scheme_machine_name_load($machine_name, $reset = FALSE) {
  $machine_name = str_replace('-', '_', $machine_name);
  $map = &drupal_static(__FUNCTION__, array());
  if (!isset($map[$machine_name]) || $reset) {
    $map[$machine_name] = db_query('SELECT sid FROM {access_scheme} WHERE machine_name = :machine_name', array(':machine_name' => $machine_name))->fetchField();
  }

  // If the given machine name does not map to any known scheme ID, abort.
  if (empty($map[$machine_name])) {
    return FALSE;
  }

  $schemes = access_scheme_load_multiple(array($map[$machine_name]), $reset);
  return reset($schemes);
}

/**
 * Loads multiple access schemes by ID.
 *
 * @param $sids
 *   An array of scheme IDs, or FALSE to load all schemes.
 * @param $reset
 *   (optional) Whether to reset the internal cache.  Defaults to FALSE.
 *
 * @return
 *   An array of access schemes indexed by their IDs. When no results are found,
 *   returns an empty array.
 *
 * @see entity_load()
 */
function access_scheme_load_multiple($sids = FALSE, $reset = FALSE) {
  return entity_load('access_scheme', $sids, array(), $reset);
}

/**
 * Saves an access scheme.
 *
 * @param $scheme
 *   An access scheme.
 *
 * @return
 *   Status constant indicating whether the scheme was inserted (SAVED_NEW) or
 *   updated (SAVED_UPDATED). When inserting a new scheme, $scheme->sid will
 *   contain the ID of the newly created scheme.
 *
 * @see AccessSchemeEntityController::save()
 */
function access_scheme_save($scheme) {
  return entity_get_controller('access_scheme')->save($scheme);
}

/**
 * Deletes an access scheme.
 *
 * @param $sid
 *   The scheme ID.
 *
 * @return
 *   Status constant indicating deletion.
 *
 * @see AccessSchemeEntityController::delete()
 */
function access_scheme_delete($sid) {
  return entity_get_controller('access_scheme')->delete($sid);
}

/**
 * Implements hook_access_scheme_insert().
 */
function access_access_scheme_insert($scheme) {
  // Create the realm field for the scheme.
  if ($realm_info = access_realm_info($scheme->realm_type)) {
    $field_name = _access_realm_field_name($scheme);

    // Create the field.
    $field = field_info_field($field_name);
    if (empty($field)) {
      $field = array(
        'field_name' => $field_name,
        'type' => $realm_info['field_type'],
        'entity_types' => array('access_grant'),
        'cardinality' => FIELD_CARDINALITY_UNLIMITED,
        'locked' => TRUE,
        // @todo Move settings to the scheme?
        'settings' => array(
          'arguments' => isset($realm_info['arguments']) ? $realm_info['arguments'] : array(),
        ),
      );
      // If the realm field is configurable, merge in any available field
      // settings attached to the scheme.
      if (!empty($field['settings']['arguments']) && isset($scheme->realm_settings)) {
        $field['settings']['arguments'] = array_merge($field['settings']['arguments'], $scheme->realm_settings);
      }
      $field = field_create_field($field);
    }

    // Create the instance.
    $instance = field_info_instance('access_grant', $field_name, $scheme->machine_name);
    if (empty($instance)) {
      $instance = array(
        'field_name' => $field_name,
        'entity_type' => 'access_grant',
        'bundle' => $scheme->machine_name,
        'label' => check_plain($scheme->name),
        'description' => filter_xss($scheme->description),
        'required' => TRUE,
      );
      $instance = field_create_instance($instance);
    }
  }
}

/**
 * Implements hook_access_scheme_update().
 */
function access_access_scheme_update($scheme) {
  // If the realm field is configurable, merge in any available field settings
  // attached to the scheme.
  // @todo Move settings to the scheme?
  $field = $scheme->realm_field;
  if (!empty($field['settings']['arguments']) && isset($scheme->realm_settings)) {
    $field['settings']['arguments'] = array_merge($field['settings']['arguments'], $scheme->realm_settings);
    field_update_field($field);
  }
}

/**
 * Returns information on available access realm types.
 *
 * @param $realm_type
 *   (optional) A realm type string.
 *
 * @return
 *   The information array for the requested $realm_type, or FALSE if not found.
 *   If $realm_type is omitted, returns information for all available types.
 *
 * @see hook_access_realm_info()
 */
function access_realm_info($realm_type = NULL) {
  $types = &drupal_static(__FUNCTION__);
  if (!isset($types)) {
    $types = array();
    foreach (module_implements('access_realm_info') as $module) {
      $info = module_invoke($module, 'access_realm_info');
      foreach (array_keys($info) as $type) {
        if (!isset($info[$type]['description'])) {
          $info[$type]['description'] = '';
        }
        $info[$type]['module'] = $module;
        $info[$type]['realm_type'] = $type;
      }
      $types += $info;
    }
    drupal_alter('access_realm_info', $types);
  }
  if (isset($realm_type)) {
    return isset($types[$realm_type]) ? $types[$realm_type] : FALSE;
  }
  return $types;
}

/**
 * Loads the info for a realm type from a URL-friendly argument.
 *
 * @param $realm_type
 *   A realm type string, where '_' may be replaced with '-'.
 *
 * @return
 *   The information array for the requested $realm_type, or FALSE if not found.
 */
function access_realm_type_load($realm_type) {
  return access_realm_info(str_replace('-', '_', $realm_type));
}

/**
 * Generates the name for the realm field in an access scheme bundle.
 *
 * This function is only intended for use internally by the access scheme insert
 * and load operations.  Once a scheme has been loaded, the name of its realm
 * field can be found at $scheme->realm_field['field_name'].
 *
 * @param $scheme
 *   An access scheme.
 *
 * @return
 *   The name to use for the realm field.
 */
function _access_realm_field_name($scheme) {
  return 'ack_' . $scheme->machine_name;
}

/**
 * Implements hook_field_info().
 *
 * @see list_field_info()
 */
function access_field_info() {
  // @todo Replace these with normal list fields (and move custom settings to the scheme?).
  $settings = array(
    'arguments' => array(),
  );

  // These are similar to the field types defined in list.module, but with an
  // 'arguments' setting to be used by ACK realm plugins and 'no_ui' set to
  // prevent access fields from being reused in other scheme bundles.
  return array(
    'access_integer' => array(
      'label' => t('Access control kit realm (integer)'),
      'description' => t('Controls access via an integer value.'),
      'settings' => $settings,
      'default_widget' => 'options_buttons',
      'default_formatter' => 'access_default',
      'no_ui' => TRUE,
    ),
    'access_float' => array(
      'label' => t('Access control kit realm (float)'),
      'description' => t('Controls access via a float value.'),
      'settings' => $settings,
      'default_widget' => 'options_buttons',
      'default_formatter' => 'access_default',
      'no_ui' => TRUE,
    ),
    'access_text' => array(
      'label' => t('Access control kit realm (text)'),
      'description' => t('Controls access via a text value.'),
      'settings' => $settings,
      'default_widget' => 'options_buttons',
      'default_formatter' => 'access_default',
      'no_ui' => TRUE,
    ),
    'access_boolean' => array(
      'label' => t('Access control kit realm (boolean)'),
      'description' => t('Controls access via a boolean value.'),
      'settings' => $settings,
      'default_widget' => 'options_buttons',
      'default_formatter' => 'access_default',
      'no_ui' => TRUE,
    ),
  );
}

/**
 * Implements hook_field_validate().
 *
 * Possible error codes:
 * - 'access_illegal_value': The value is not in the list of allowed values.
 *
 * @see list_field_validate()
 */
function access_field_validate($entity_type, $entity, $field, $instance, $langcode, $items, &$errors) {
  $allowed_values = access_field_allowed_values($field);
  foreach ($items as $delta => $item) {
    if (!empty($item['value'])) {
      if (empty($allowed_values) || !isset($allowed_values[$item['value']])) {
        $errors[$field['field_name']][$langcode][$delta][] = array(
          'error' => 'access_illegal_value',
          'message' => t('%name: illegal value.', array('%name' => $instance['label'])),
        );
      }
    }
  }
}

/**
 * Implements hook_field_is_empty().
 *
 * @see list_field_is_empty()
 */
function access_field_is_empty($item, $field) {
  if (empty($item['value']) && (string) $item['value'] !== '0') {
    return TRUE;
  }
  return FALSE;
}

/**
 * Returns the set of allowed values (realms) for an access field.
 *
 * @param $field
 *   The field definition.
 *
 * @return
 *   The array of allowed values. Keys of the array are the raw stored values
 *   (number or text), values of the array are the display labels.
 */
function access_field_allowed_values($field) {
  // Access realm fields should only be a member of one scheme.
  if (!empty($field['bundles']['access_grant'])) {
    $scheme = access_scheme_machine_name_load(reset($field['bundles']['access_grant']));
    return $scheme->realms;
  }
}

/**
 * Implements hook_field_widget_info_alter().
 *
 * @see list_field_widget_info_alter()
 */
function access_field_widget_info_alter(&$info) {
  $widgets = array(
    'options_select' => array('access_integer', 'access_float', 'access_text'),
    'options_buttons' => array('access_integer', 'access_float', 'access_text', 'access_boolean'),
    'options_onoff' => array('access_boolean'),
  );

  foreach ($widgets as $widget => $field_types) {
    $info[$widget]['field types'] = array_merge($info[$widget]['field types'], $field_types);
  }
}

/**
 * Implements hook_options_list().
 */
function access_options_list($field, $instance, $entity_type, $entity) {
  return access_field_allowed_values($field);
}

/**
 * Implements hook_field_settings_form().
 *
 * @see hook_access_realm_settings()
 */
function access_field_settings_form($field, $instance, $has_data) {
  // @todo Move settings to the scheme?
  $form = array();
  // Make sure the field is an access field.
  // Only supports a one-to-one relationship between schemes and access fields.
  if (!empty($field['bundles']['access_grant'])) {
    $scheme = access_scheme_machine_name_load(reset($field['bundles']['access_grant']));
    $form['arguments'] = module_invoke($scheme->realm_info['module'], 'access_realm_settings', $scheme->realm_type, $has_data, $field['settings']['arguments']);
    $form['arguments']['#tree'] = TRUE;
  }
  return $form;
}

/**
 * Implements hook_field_formatter_info().
 *
 * @see list_field_formatter_info()
 */
function access_field_formatter_info() {
  return array(
    'access_default' => array(
      'label' => t('Default'),
      'field types' => array('access_integer', 'access_float', 'access_text', 'access_boolean'),
    ),
  );
}

/**
 * Implements hook_field_formatter_view().
 *
 * @see list_field_formatter_view()
 */
function access_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();

  switch ($display['type']) {
    case 'access_default':
      $allowed_values = access_field_allowed_values($field);
      foreach ($items as $delta => $item) {
        if (isset($allowed_values[$item['value']])) {
          $output = field_filter_xss($allowed_values[$item['value']]);
        }
        else {
          // If no match was found in allowed values, fall back to the key.
          $output = field_filter_xss($item['value']);
        }
        $element[$delta] = array('#markup' => $output);
      }
      break;
  }

  return $element;
}

/**
 * Implements hook_field_extra_fields().
 */
function access_field_extra_fields() {
  $extra = array();
  $fields = array(
    'user' => array(
      'label' => t('User'),
      'description' => t('Access control kit user reference'),
      'weight'=> -5,
    ),
    'role' => array(
      'label' => t('Role'),
      'description' => t('Access control kit role reference'),
      'weight' => -4,
    ),
  );
  foreach (array_keys(access_scheme_names()) as $machine_name) {
    $extra['access_grant'][$machine_name] = array(
      'form' => $fields,
      'display' => $fields,
    );
  }
  return $extra;
}

/**
 * Returns information on all available object access handlers.
 *
 * @return
 *   An array indexed by handler name where each value is an associative array
 *   with the following keys:
 *   - label: The human-readable name of this handler.
 *   - realm types: An array listing the realm types that this handler supports,
 *     as defined in hook_access_realm_info().
 *   - object types: An array listing the object types that this handler
 *     supports, as defined in hook_access_info(). A value of 'fieldable entity'
 *     indicates that the handler supports all object types that are fieldable
 *     entities, as defined by hook_entity_info().
 *   - class: The name of the handler class.
 *   - module: The module that provides the handler class.
 *
 * @see hook_access_handler_info()
 * @see hook_access_handler_info_alter()
 */
function access_handler_info() {
  // @todo Make all of the _info() functions consistent.
  $info = &drupal_static(__FUNCTION__, array());
  if (empty($info)) {
    if ($cache = cache_get('access_handler_info')) {
      $info = $cache->data;
    }
    else {
      foreach (module_implements('access_handler_info') as $module) {
        if ($module_info = module_invoke($module, 'access_handler_info')) {
          foreach ($module_info as $handler_name => $handler_info) {
            // Merge in default values.
            $module_info[$handler_name] += array(
              'label' => '',
              'realm types' => array(),
              'object types' => array(),
            );
            // Set inferred values.
            $module_info[$handler_name]['class'] = $handler_name;
            $module_info[$handler_name]['module'] = $module;
          }
          $info += $module_info;
        }
      }
      drupal_alter('access_handler_info', $info);
      cache_set('access_handler_info', $info);
    }
  }
  return $info;
}

/**
 * Saves an access handler attachment to the database.
 *
 * @param $scheme
 *   The access scheme to which the handler will be attached.
 * @param $object_type
 *   The type of Drupal object that the handler will manage (e.g., node).
 * @param $class
 *   The name of the access handler class.
 * @param $module
 *   The module that provides the handler.
 * @param $settings
 *   (optional) An array of settings to control the handler's behavior.
 *
 * @return
 *   Status constant indicating whether the handler attachment was inserted
 *   (SAVED_NEW) or updated (SAVED_UPDATED).
 */
function access_handler_save($scheme, $object_type, $class, $module, $settings = array()) {
  // The scheme and object type pairing must be unique (i.e., there cannnot be
  // more than one handler for a given object type attached to the scheme).
  $key = array(
    'scheme' => $scheme->machine_name,
    'object_type' => $object_type,
  );
  $fields = array(
    'handler' => $class,
    'module' => $module,
    'settings' => is_array($settings) ? $settings : array($settings),
  );
  $fields['settings'] = serialize($fields['settings']);

  // Add/update the attachment.
  $status = db_merge('access_handler')
    ->key($key)
    ->fields($fields)
    ->execute();
  return $status;
}

/**
 * Deletes an access handler attachment from the database.
 *
 * @param $scheme
 *   The access scheme to which the handler is currently attached.
 * @param $object_type
 *   The type of Drupal object that the handler manages (e.g., node).
 */
function access_handler_delete($scheme, $object_type) {
  db_delete('access_handler')
    ->condition('scheme', $scheme->machine_name)
    ->condition('object_type', $object_type)
    ->execute();
}

/**
 * AJAX callback for access handler settings forms.
 *
 * @see access_scheme_form()
 */
function access_handler_form_ajax($form, $form_state) {
  // The triggering element should be the handler selector, which should have
  // #parents like so:
  //
  // array(
  //   [0] => 'handlers',
  //   [1] => a string indicating the object type that this handler manages,
  //   [2] => 'handler',
  //
  // Thus, we can use the second element in the array to determine which handler
  // settings form needs to be rebuilt.
  $object_type = $form_state['triggering_element']['#parents'][1];
  return $form['handlers'][$object_type]['settings'];
}

/**
 * Returns information on all available access-controlled object types.
 *
 * @return
 *   An array indexed by object type (e.g., node, menu_link) where each value is
 *   an associative array with the following keys:
 *   - label: The human-readable name of this object type (e.g., "Content",
 *     "Menu link").
 *   - type: The machine name of this object type (e.g., node, menu_link).
 *   - module: The module that provides ACK-compatibility for the object type.
 *   - fieldable: Boolean indicating whether or not this object type is a
 *     fieldable entity, as defined by hook_entity_info().
 *   - handlers: An array listing the access handlers that support this object
 *     type, as defined in hook_access_handler_info().
 *
 * @see hook_access_info()
 * @see hook_access_info_alter()
 */
function access_info() {
  $info = &drupal_static(__FUNCTION__, array());
  if (empty($info)) {
    if ($cache = cache_get('access_info')) {
      $info = $cache->data;
    }
    else {
      $handlers = access_handler_info();
      foreach (module_implements('access_info') as $module) {
        if ($module_info = module_invoke($module, 'access_info')) {
          foreach ($module_info as $object_type => $object_info) {
            $info[$object_type]['label'] = $object_info['label'];
            $info[$object_type]['type'] = $object_type;
            $info[$object_type]['module'] = $module;

            // Check whether the object is a fieldable entity.
            $entity_info = entity_get_info($object_type);
            $info[$object_type]['fieldable'] = empty($entity_info) ? FALSE : $entity_info['fieldable'];

            // Find handlers that support this object type.
            $info[$object_type]['handlers'] = array();
            foreach ($handlers as $handler_name => $handler_info) {
              // If the object is a fieldable entity and the handler supports
              // fieldable entities, or if the handler explicitly supports this
              // object type, add the handler to the list.
              if (($info[$object_type]['fieldable'] && in_array('fieldable entity', $handler_info['object types'])) || in_array($object_type, $handler_info['object types'])) {
                $info[$object_type]['handlers'][] = $handler_name;
              }
            }
          }
        }
      }
      drupal_alter('access_info', $info);
      cache_set('access_info', $info);
    }
  }
  return $info;
}

/**
 * Finds all access schemes that control access to a given object type.
 *
 * @param $object_type
 *   An access-controlled object type name (e.g., node, menu_link), as defined
 *   by hook_access_info().
 * @param $names_only
 *   (optional) If set to TRUE, the returned array will contain only the names
 *   of the applicable access schemes, rather than fully loaded scheme entities.
 *   Defaults to FALSE.
 *
 * @return
 *   An array containing all access schemes that have an object access handler
 *   attached for the given object type, keyed by scheme machine name.
 */
function access_object_schemes($object_type, $names_only = FALSE) {
  $object_schemes = &drupal_static(__FUNCTION__, array());

  // Get the machine names and IDs for all schemes that have a handler attached
  // for the given object type.
  if (!isset($object_schemes[$object_type])) {
    $object_schemes[$object_type] = db_query('SELECT s.machine_name, s.sid FROM {access_scheme} s INNER JOIN {access_handler} h ON s.machine_name = h.scheme WHERE h.object_type = :object_type', array(':object_type' => $object_type))->fetchAllKeyed();
  }

  // Return either the names or the objects for the applicable schemes.
  $scheme_list = array();
  if (!empty($object_schemes[$object_type])) {
    if ($names_only) {
      $scheme_list = array_intersect_key(access_scheme_names(), $object_schemes[$object_type]);
    }
    else {
      $schemes = access_scheme_load_multiple($object_schemes[$object_type]);
      foreach ($object_schemes[$object_type] as $machine_name => $sid) {
        $scheme_list[$machine_name] = $schemes[$sid];
      }
    }
  }
  return $scheme_list;
}

/**
 * Returns a list of an object's realm memberships.
 *
 * @param $object_type
 *   The type of access-controlled object (e.g., node, menu_link).
 * @param $object
 *   The access-controlled object.
 * @param $schemes
 *   (optional) An array of access schemes, used to limit the list of returned
 *   realm memberships.  If omitted, the returned list will include realm
 *   memberships for all schemes that apply to the object type.
 *
 * @return
 *   An array indexed by scheme machine name where each value is an array of
 *   realm values.  If the object is not a member of any realm in a scheme, the
 *   value returned for that scheme will be array().
 */
function access_object_realms($object_type, $object, $schemes = NULL) {
  if (!isset($schemes)) {
    $schemes = access_object_schemes($object_type);
  }
  $realms = array();
  foreach ($schemes as $scheme) {
    $realms[$scheme->machine_name] = isset($scheme->handlers[$object_type]) ? $scheme->handlers[$object_type]->objectRealms($object_type, $object) : array();
  }
  return $realms;
}

/**
 * Returns a list of a user's realm-level role memberships.
 *
 * @param $account
 *   (optional) The account to check. Defaults to the currently logged in user.
 *
 * @return
 *   A nested array indexed first by role ID, then by scheme machine name, where
 *   each value is an array containing the user's assigned realms for that role
 *   in that scheme. Note that the list of roles is limited to those found in
 *   $scheme->roles for each scheme; non-ACK roles are excluded.
 */
function access_user_roles($account = NULL) {
  global $user;
  if (!isset($account)) {
    $account = $user;
  }

  // Cache the user's role list using the advanced drupal_static() pattern for
  // best performance on repeated access checks.
  static $drupal_static_fast;
  if (!isset($drupal_static_fast)) {
    $drupal_static_fast['user_roles'] = &drupal_static(__FUNCTION__);
  }
  $user_roles = &$drupal_static_fast['user_roles'];

  // On cache miss, load all grants for the user and sort by role and scheme.
  if (!isset($user_roles[$account->uid])) {
    $grants = access_grant_load_by_condition(array('uid' => $account->uid));
    $roles = array();
    foreach ($grants as $grant) {
      $scheme = access_scheme_machine_name_load($grant->scheme);
      // Only include roles that are in the current list of ACK-enabled roles
      // (in case the scheme settings have changed), and that are currently
      // associated with the user (in case another module revoked a role without
      // ACK being notified to clean up grants).
      if (isset($scheme->roles[$grant->rid]) && isset($account->roles[$grant->rid])) {
        $roles[$grant->rid][$grant->scheme] = access_grant_realms($grant);
      }
    }
    $user_roles[$account->uid] = $roles;
  }

  return $user_roles[$account->uid];
}

/**
 * Returns a list of realms in which the user has a given permission.
 *
 * @param $string
 *   The permission string (e.g., edit any page).
 * @param $account
 *   (optional) The account to check. Defaults to the currently logged in user.
 * @param $schemes
 *   (optional) An array of access schemes, used to limit the list of returned
 *   realms.  If omitted, the returned list will include realms for all schemes.
 *
 * @return
 *   An array indexed by scheme machine name where each value is an array of
 *   realm values.  If the user does not have the permission for any realm in a
 *   scheme, the value returned for that scheme will be array().
 */
function access_user_permission_realms($string, $account = NULL, $schemes = NULL) {
  global $user;
  if (!isset($account)) {
    $account = $user;
  }

  if (!isset($schemes)) {
    $schemes = access_scheme_load_multiple();
  }

  // Get the user's realm-level role memberships.
  $roles = access_user_roles($account);
  // Filter out any roles that do not include the permission we're looking for.
  foreach (user_role_permissions($roles) as $rid => $permissions) {
    if (empty($permissions[$string])) {
      unset($roles[$rid]);
    }
  }

  // Find the accessible realms for each scheme.
  $realms = array();
  foreach ($schemes as $scheme) {
    $scheme_realms = array();
    foreach ($roles as $access) {
      if (!empty($access[$scheme->machine_name])) {
        $scheme_realms += $access[$scheme->machine_name];
      }
    }
    $realms[$scheme->machine_name] = $scheme_realms;
  }
  return $realms;
}

/**
 * Determines whether a user has a permission on an object via an access grant.
 *
 * @param $string
 *   The permission string (e.g., edit any page).
 * @param $object_type
 *   The type of access-controlled object (e.g., node, menu_link).
 * @param $object
 *   The access-controlled object.
 * @param $account
 *   (optional) The account to check. Defaults to the currently logged in user.
 * @param $schemes
 *   (optional) An array of schemes in which to check access on the object. If
 *   omitted, access will be checked in all available schemes that apply to the
 *   object type.
 *
 * @return
 *   Boolean TRUE if the user has the requested permission on the object in any
 *   of the tested schemes.
 */
function access_user_object_access($string, $object_type, $object, $account = NULL, $schemes = NULL) {
  global $user;
  if (!isset($account)) {
    $account = $user;
  }

  // Sanity check to make sure that the user has the permission at all.
  if (user_access($string, $account)) {
    if (!isset($schemes)) {
      $schemes = access_object_schemes($object_type);
    }

    // Get the list of realms wherein the user has the permission.
    $user_realms = access_user_permission_realms($string, $account, $schemes);

    // Get the object's realm memberships.
    $object_realms = access_object_realms($object_type, $object, $schemes);

    // If the user has the permission in any realm of which the object is also a
    // member, return TRUE to allow access.
    foreach ($schemes as $scheme) {
      $matches = array_intersect($user_realms[$scheme->machine_name], $object_realms[$scheme->machine_name]);
      if (!empty($matches)) {
        return TRUE;
      }
    }
  }
  return FALSE;
}

/**
 * Implements hook_permission().
 */
function access_permission() {
  $perms['administer access schemes'] = array(
    'title' => t('Administer access schemes'),
    'description' => t('Define the means by which objects in the site are divided into access realms.'),
    'restrict access' => TRUE,
  );
  $perms['administer access grants'] = array(
    'title' => t('Administer access grants'),
    'description' => t('Assign roles to users within access realms.'),
    'restrict access' => TRUE,
  );
  return $perms;
}

/**
 * Implements hook_menu().
 */
function access_menu() {
  // Manage access grants.
  $items['admin/access'] = array(
    'title' => 'Access',
    'description' => 'Manage access grants.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('access_overview_grants'),
    'access arguments' => array('administer access grants'),
    // -2 places it between "People" and "Modules" on the default admin menu.
    'weight' => -2,
    'file' => 'access_grants.admin.inc',
  );
  $items['admin/access/list'] = array(
    'title' => 'List',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $items['admin/access/add'] = array(
    'title' => 'Add access grant',
    'page callback' => 'access_grant_add_list',
    'access arguments' => array('administer access grants'),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'access_grants.admin.inc',
  );
  $items['admin/access/add/%access_scheme_machine_name'] = array(
    'title' => 'Add access grant for scheme',
    'title callback' => 'access_grant_add_page_title',
    'title arguments' => array(3),
    'page callback' => 'access_grant_add',
    'page arguments' => array(3),
    'access arguments' => array('administer access grants'),
    'file' => 'access_grants.admin.inc',
  );
  $items['admin/access/grant/%access_grant'] = array(
    'title callback' => 'entity_label',
    'title arguments' => array('access_grant', 3),
    'page callback' => 'access_grant_page',
    'page arguments' => array(3),
    'access arguments' => array('administer access grants'),
    'file' => 'access.pages.inc',
  );
  $items['admin/access/grant/%access_grant/view'] = array(
    'title' => 'View',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $items['admin/access/grant/%access_grant/edit'] = array(
    'title' => 'Edit',
    'page callback' => 'access_grant_edit',
    'page arguments' => array(3),
    'access arguments' => array('administer access grants'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'access_grants.admin.inc',
  );
  $items['admin/access/grant/%access_grant/delete'] = array(
    'title' => 'Delete',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('access_grant_delete_confirm', 3),
    'access arguments' => array('administer access grants'),
    'file' => 'access_grants.admin.inc',
  );

  // Manage access schemes.
  $items['admin/structure/access'] = array(
    'title' => 'Access schemes',
    'description' => 'Define access control schemes.',
    'page callback' => 'access_overview_schemes',
    'access arguments' => array('administer access schemes'),
    'file' => 'access_schemes.admin.inc',
  );
  $items['admin/structure/access/list'] = array(
    'title' => 'List',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $items['admin/structure/access/add'] = array(
    'title' => 'Add access scheme',
    'page callback' => 'access_scheme_add_list',
    'access arguments' => array('administer access schemes'),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'access_schemes.admin.inc',
  );
  $items['admin/structure/access/add/%access_realm_type'] = array(
    'title' => 'Add access scheme',
    'page callback' => 'access_scheme_add',
    'page arguments' => array(4),
    'access arguments' => array('administer access schemes'),
    'file' => 'access_schemes.admin.inc',
  );
  $items['admin/structure/access/%access_scheme_machine_name'] = array(
    'title callback' => 'entity_label',
    'title arguments' => array('access_scheme', 3),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('access_scheme_form', 3),
    'access arguments' => array('administer access schemes'),
    'file' => 'access_schemes.admin.inc',
  );
  $items['admin/structure/access/%access_scheme_machine_name/edit'] = array(
    'title' => 'Edit',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );
  $items['admin/structure/access/%access_scheme_machine_name/delete'] = array(
    'title' => 'Delete',
    'page arguments' => array('access_scheme_delete_confirm', 3),
    'access arguments' => array('administer access schemes'),
    'file' => 'access_schemes.admin.inc',
  );

  return $items;
}

/**
 * Implements hook_theme().
 */
function access_theme() {
  return array(
    'access_overview_scheme_name' => array(
      'variables' => array('scheme' => NULL),
      'file' => 'access_schemes.admin.inc',
    ),
    'access_grant' => array(
      'render element' => 'elements',
      'template' => 'access-grant',
      'file' => 'access.pages.inc',
    ),
  );
}

/**
 * Implements hook_hook_info().
 */
function access_hook_info() {
  $group = array('group' => 'access');
  $list = array(
    'access_info',
    'access_handler_info',
    'access_realm_info',
    'access_realm_settings',
    'access_realms',
    'access_scheme_presave',
    'access_scheme_insert',
    'access_scheme_update',
    'access_scheme_delete',
    'access_grant_presave',
    'access_grant_insert',
    'access_grant_update',
    'access_grant_delete',
    'access_grant_view',
  );
  $hooks = array();
  foreach ($list as $hook) {
    $hooks[$hook] = $group;
  }
  return $hooks;
}
