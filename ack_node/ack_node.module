<?php
/**
 * @file
 * The ACK node module.
 */

/**
 * Implements hook_access_info().
 */
function ack_node_access_info() {
  // Declare support for controlling access to nodes.
  $info['node'] = array('label' => t('Content'));
  return $info;
}

/**
 * Implements hook_access_handler_info().
 */
function ack_node_access_handler_info() {
  // Handlers for node properties.
  $info['ACKNodeAuthor'] = array(
    'label' => t('is author'),
    'realm types' => array('user'),
    'object types' => array('node'),
  );
  $info['ACKNodeSticky'] = array(
    'label' => t('is sticky'),
    'realm types' => array('boolean'),
    'object types' => array('node'),
  );

  // Handler for the taxonomy index.
  if (module_exists('taxonomy')) {
    $info['ACKNodeTaxonomyIndex'] = array(
      'label' => t('term association'),
      'realm types' => array('taxonomy_term'),
      'object types' => array('node'),
    );
  }

  return $info;
}

/**
 * Returns a list of access schemes that use a node handler.
 *
 * @return
 *   An array of scheme names, keyed by machine name.
 */
function ack_node_schemes() {
  $list = array();
  foreach (access_scheme_get_schemes() as $scheme) {
    if (!empty($scheme->handlers['node'])) {
      $list[$scheme->scheme] = $scheme->name;
    }
  }
  return $list;
}

/**
 * Implements hook_permission().
 */
function ack_node_permission() {
  // Create scheme-level create/edit/delete permissions for each content type.
  $perms = array();
  $schemes = ack_node_schemes();
  foreach (node_permissions_get_configured_types() as $type) {
    $type_info = node_type_get_type($type);
    foreach ($schemes as $scheme => $scheme_name) {
      $t_args = array('%type_name' => $type_info->name, '%scheme_name' => $scheme_name);
      $perms += array(
        "create $type content in ack $scheme" => array(
          'title' => t('%type_name: Create new content in assigned %scheme_name', $t_args),
        ),
        "edit own $type content in ack $scheme" => array(
          'title' => t('%type_name: Edit own content in assigned %scheme_name', $t_args),
        ),
        "edit any $type content in ack $scheme" => array(
          'title' => t('%type_name: Edit any content in assigned %scheme_name', $t_args),
        ),
        "delete own $type content in ack $scheme" => array(
          'title' => t('%type_name: Delete own content in assigned %scheme_name', $t_args),
        ),
        "delete any $type content in ack $scheme" => array(
          'title' => t('%type_name: Delete any content in assigned %scheme_name', $t_args),
        ),
      );
    }
  }
  return $perms;
}

/**
 * Implements hook_node_access().
 */
function ack_node_node_access($node, $op, $account) {
  $type = is_string($node) ? $node : $node->type;

  if (in_array($type, node_permissions_get_configured_types())) {
    foreach (array_keys(ack_node_schemes()) as $scheme) {
      if ($op == 'create' && user_access('create ' . $type . ' content in ack ' . $scheme, $account)) {
        return NODE_ACCESS_ALLOW;
      }

      if ($op == 'update') {
        if (access_user_object_access('edit any ' . $type . ' content in ack ' . $scheme, 'node', $node, $scheme, $account) || (access_user_object_access('edit own ' . $type . ' content in ack ' . $scheme, 'node', $node, $scheme, $account) && ($account->uid == $node->uid))) {
          return NODE_ACCESS_ALLOW;
        }
      }

      if ($op == 'delete') {
        if (access_user_object_access('delete any ' . $type . ' content in ack ' . $scheme, 'node', $node, $scheme, $account) || (access_user_object_access('delete own ' . $type . ' content in ack ' . $scheme, 'node', $node, $scheme, $account) && ($account->uid == $node->uid))) {
          return NODE_ACCESS_ALLOW;
        }
      }
    }
  }

  // Returning nothing from this function would have the same effect.
  return NODE_ACCESS_IGNORE;
}

/**
 * Implements hook_form_BASE_FORM_ID_alter().
 *
 * Alters the node form to filter the options on ACK-related elements.
 */
function ack_node_form_node_form_alter(&$form, &$form_state, $form_id) {
  global $user;
  $node = $form_state['node'];
  $schemes = array_keys(ack_node_schemes());

  // If we are creating a new node, check the create permissions.
  if (empty($node->nid)) {
    // Global access trumps scheme-level access.
    if (user_access('create ' . $node->type . ' content')) {
      return;
    }

    // Otherwise, only allow the node to be created in granted realms.
    foreach ($schemes as $machine_name) {
      $realms = access_user_permission_realms('create ' . $node->type . ' content in ack ' . $machine_name, $machine_name);
      $scheme = access_scheme_get_scheme($machine_name);
      $scheme->handlers['node']->formAlterNew($form, $form_state, $form_id, $node, $realms);
    }
  }
  // If we are editing an existing node, check the delete permissions.
  else {
    // Again, global access trumps scheme-level access.
    if (user_access('delete any ' . $node->type . ' content') || (user_access('delete own ' . $node->type . ' content') && ($user->uid == $node->uid))) {
      return;
    }

    // Otherwise, lock down the access-related fields/properties and restrict
    // access to the delete button by realm.
    foreach ($schemes as $machine_name) {
      $realms = access_user_permission_realms('delete any ' . $node->type . ' content in ack ' . $machine_name, $machine_name);
      if ($user->uid == $node->uid) {
        $realms += access_user_permission_realms('delete own ' . $node->type . ' content in ack ' . $machine_name, $machine_name);
      }
      $scheme = access_scheme_get_scheme($machine_name);
      $scheme->handlers['node']->formAlterExisting($form, $form_state, $form_id, $node, $realms);
    }
  }
}
